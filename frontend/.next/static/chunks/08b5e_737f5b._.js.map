{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/internal/hex.js"],"sourcesContent":["import * as Hex from '../Hex.js';\n/** @internal */\nexport function assertSize(hex, size_) {\n    if (Hex.size(hex) > size_)\n        throw new Hex.SizeOverflowError({\n            givenSize: Hex.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1)\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Hex.size(value),\n        });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Hex.size(value) !== end - start) {\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Hex.size(value),\n        });\n    }\n}\n/** @internal */\nexport function pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new Hex.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nexport function trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map"],"names":[],"mappings":";;;;;;;;;;AAEO,SAAS,WAAW,GAAG,EAAE,KAAK;IACjC,IAAI,6IAAI,IAAI,CAAC,OAAO,OAChB,MAAM,IAAI,6IAAI,iBAAiB,CAAC;QAC5B,WAAW,6IAAI,IAAI,CAAC;QACpB,SAAS;IACb;AACR;AAEO,SAAS,kBAAkB,KAAK,EAAE,KAAK;IAC1C,IAAI,OAAO,UAAU,YAAY,QAAQ,KAAK,QAAQ,6IAAI,IAAI,CAAC,SAAS,GACpE,MAAM,IAAI,6IAAI,2BAA2B,CAAC;QACtC,QAAQ;QACR,UAAU;QACV,MAAM,6IAAI,IAAI,CAAC;IACnB;AACR;AAEO,SAAS,gBAAgB,KAAK,EAAE,KAAK,EAAE,GAAG;IAC7C,IAAI,OAAO,UAAU,YACjB,OAAO,QAAQ,YACf,6IAAI,IAAI,CAAC,WAAW,MAAM,OAAO;QACjC,MAAM,IAAI,6IAAI,2BAA2B,CAAC;YACtC,QAAQ;YACR,UAAU;YACV,MAAM,6IAAI,IAAI,CAAC;QACnB;IACJ;AACJ;AAEO,SAAS,IAAI,IAAI,EAAE,UAAU,CAAC,CAAC;IAClC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE,GAAG;IAC3B,IAAI,SAAS,GACT,OAAO;IACX,MAAM,MAAM,KAAK,OAAO,CAAC,MAAM;IAC/B,IAAI,IAAI,MAAM,GAAG,OAAO,GACpB,MAAM,IAAI,6IAAI,2BAA2B,CAAC;QACtC,MAAM,KAAK,IAAI,CAAC,IAAI,MAAM,GAAG;QAC7B,YAAY;QACZ,MAAM;IACV;IACJ,OAAO,CAAC,EAAE,EAAE,GAAG,CAAC,QAAQ,UAAU,WAAW,WAAW,CAAC,OAAO,GAAG,KAAK,CAAC;AAC7E;AAEO,SAAS,KAAK,KAAK,EAAE,UAAU,CAAC,CAAC;IACpC,MAAM,EAAE,MAAM,MAAM,EAAE,GAAG;IACzB,IAAI,OAAO,MAAM,OAAO,CAAC,MAAM;IAC/B,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,GAAG,GAAG,IAAK;QACtC,IAAI,IAAI,CAAC,QAAQ,SAAS,IAAI,KAAK,MAAM,GAAG,IAAI,EAAE,CAAC,QAAQ,OAAO,KAC9D;aAEA;IACR;IACA,OACI,QAAQ,SACF,KAAK,KAAK,CAAC,eACX,KAAK,KAAK,CAAC,GAAG,KAAK,MAAM,GAAG;IACtC,IAAI,SAAS,KACT,OAAO;IACX,IAAI,QAAQ,WAAW,KAAK,MAAM,GAAG,MAAM,GACvC,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;IACvB,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC;AACtB,EACA,+BAA+B"}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Json.js"],"sourcesContent":["const bigIntSuffix = '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nexport function parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nexport function stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map"],"names":[],"mappings":";;;;AAAA,MAAM,eAAe;AAmBd,SAAS,MAAM,MAAM,EAAE,OAAO;IACjC,OAAO,KAAK,KAAK,CAAC,QAAQ,CAAC,KAAK;QAC5B,MAAM,QAAQ;QACd,IAAI,OAAO,UAAU,YAAY,MAAM,QAAQ,CAAC,eAC5C,OAAO,OAAO,MAAM,KAAK,CAAC,GAAG,CAAC,aAAa,MAAM;QACrD,OAAO,OAAO,YAAY,aAAa,QAAQ,KAAK,SAAS;IACjE;AACJ;AAoBO,SAAS,UAAU,KAAK,EAAE,QAAQ,EAAE,KAAK;IAC5C,OAAO,KAAK,SAAS,CAAC,OAAO,CAAC,KAAK;QAC/B,IAAI,OAAO,aAAa,YACpB,OAAO,SAAS,KAAK;QACzB,IAAI,OAAO,UAAU,UACjB,OAAO,MAAM,QAAQ,KAAK;QAC9B,OAAO;IACX,GAAG;AACP,EACA,gCAAgC"}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 90, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/version.js"],"sourcesContent":["/** @internal */\nexport const version = '0.1.1';\n//# sourceMappingURL=version.js.map"],"names":[],"mappings":"AAAA,cAAc;;;AACP,MAAM,UAAU,SACvB,mCAAmC"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 99, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/internal/errors.js"],"sourcesContent":["import { version } from '../version.js';\n/** @internal */\nexport function getUrl(url) {\n    return url;\n}\n/** @internal */\nexport function getVersion() {\n    return version;\n}\n/** @internal */\nexport function prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map"],"names":[],"mappings":";;;;;;;;AAEO,SAAS,OAAO,GAAG;IACtB,OAAO;AACX;AAEO,SAAS;IACZ;AACJ;AAEO,SAAS,YAAY,IAAI;IAC5B,IAAI,CAAC,MACD,OAAO;IACX,MAAM,UAAU,OAAO,OAAO,CAAC,MAC1B,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM;QAClB,IAAI,UAAU,aAAa,UAAU,OACjC,OAAO;QACX,OAAO;YAAC;YAAK;SAAM;IACvB,GACK,MAAM,CAAC;IACZ,MAAM,YAAY,QAAQ,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,GAAK,KAAK,GAAG,CAAC,KAAK,IAAI,MAAM,GAAG;IAC5E,OAAO,QACF,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM,GAAK,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,GAAG,EAAE,EAAE,MAAM,CAAC,EACtE,IAAI,CAAC;AACd,EACA,kCAAkC"}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Errors.js"],"sourcesContent":["import { getVersion } from './internal/errors.js';\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nexport class BaseError extends Error {\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = 'https://oxlib.sh';\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: `ox@${getVersion()}`\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map"],"names":[],"mappings":";;;;;;AAUO,MAAM,kBAAkB;IAC3B,YAAY,YAAY,EAAE,UAAU,CAAC,CAAC,CAAE;QACpC,MAAM,UAAU,AAAC,CAAA;YACb,IAAI,QAAQ,KAAK,YAAY,WAAW;gBACpC,IAAI,QAAQ,KAAK,CAAC,OAAO,EACrB,OAAO,QAAQ,KAAK,CAAC,OAAO;gBAChC,IAAI,QAAQ,KAAK,CAAC,YAAY,EAC1B,OAAO,QAAQ,KAAK,CAAC,YAAY;YACzC;YACA,IAAI,QAAQ,KAAK,EAAE,SACf,OAAO,QAAQ,KAAK,CAAC,OAAO;YAChC,OAAO,QAAQ,OAAO;QAC1B,CAAA;QACA,MAAM,WAAW,AAAC,CAAA;YACd,IAAI,QAAQ,KAAK,YAAY,WACzB,OAAO,QAAQ,KAAK,CAAC,QAAQ,IAAI,QAAQ,QAAQ;YACrD,OAAO,QAAQ,QAAQ;QAC3B,CAAA;QACA,MAAM,cAAc;QACpB,MAAM,OAAO,CAAC,EAAE,YAAY,EAAE,YAAY,GAAG,CAAC;QAC9C,MAAM,UAAU;YACZ,gBAAgB;eACZ,QAAQ,YAAY,GAAG;gBAAC;mBAAO,QAAQ,YAAY;aAAC,GAAG,EAAE;eACzD,WAAW,WACT;gBACE;gBACA,UAAU,CAAC,SAAS,EAAE,QAAQ,CAAC,GAAG;gBAClC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG;aAC/B,GACC,EAAE;SACX,CACI,MAAM,CAAC,CAAC,IAAM,OAAO,MAAM,UAC3B,IAAI,CAAC;QACV,KAAK,CAAC,SAAS,QAAQ,KAAK,GAAG;YAAE,OAAO,QAAQ,KAAK;QAAC,IAAI;QAC1D,OAAO,cAAc,CAAC,IAAI,EAAE,WAAW;YACnC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,YAAY;YACpC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB;YACxC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,SAAS;YACjC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,WAAW;YACnC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,CAAC,GAAG,EAAE,4KAAa,CAAC;QAC/B;QACA,IAAI,CAAC,KAAK,GAAG,QAAQ,KAAK;QAC1B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;IACxB;IACA,KAAK,EAAE,EAAE;QACL,OAAO,KAAK,IAAI,EAAE;IACtB;AACJ;AACA,cAAc,GACd,SAAS,KAAK,GAAG,EAAE,EAAE;IACjB,IAAI,KAAK,MACL,OAAO;IACX,IAAI,OAAO,OAAO,QAAQ,YAAY,WAAW,OAAO,IAAI,KAAK,EAC7D,OAAO,KAAK,IAAI,KAAK,EAAE;IAC3B,OAAO,KAAK,OAAO;AACvB,EACA,kCAAkC"}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Bytes.js"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\nimport * as internal from './internal/bytes.js';\nimport * as internal_hex from './internal/hex.js';\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nexport function assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nexport function concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        internal_hex.assertSize(value, size);\n        hex = Hex.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new Errors.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromNumber(value, options) {\n    const hex = Hex.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nexport function isEqual(bytesA, bytesB) {\n    return equalBytes(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nexport function random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nexport function size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nexport function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nexport function toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nexport function toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value, options = {}) {\n    return Hex.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nexport function toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nexport function toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nexport function validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nexport class InvalidBytesBooleanError extends Errors.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nexport class InvalidBytesTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 493, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/internal/bytes.js"],"sourcesContent":["import * as Bytes from '../Bytes.js';\n/** @internal */\nexport function assertSize(bytes, size_) {\n    if (Bytes.size(bytes) > size_)\n        throw new Bytes.SizeOverflowError({\n            givenSize: Bytes.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Bytes.size(value),\n        });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Bytes.size(value) !== end - start) {\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Bytes.size(value),\n        });\n    }\n}\n/** @internal */\nexport const charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nexport function charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nexport function pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new Bytes.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nexport function trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAEO,SAAS,WAAW,KAAK,EAAE,KAAK;IACnC,IAAI,+IAAM,IAAI,CAAC,SAAS,OACpB,MAAM,IAAI,+IAAM,iBAAiB,CAAC;QAC9B,WAAW,+IAAM,IAAI,CAAC;QACtB,SAAS;IACb;AACR;AAEO,SAAS,kBAAkB,KAAK,EAAE,KAAK;IAC1C,IAAI,OAAO,UAAU,YAAY,QAAQ,KAAK,QAAQ,+IAAM,IAAI,CAAC,SAAS,GACtE,MAAM,IAAI,+IAAM,2BAA2B,CAAC;QACxC,QAAQ;QACR,UAAU;QACV,MAAM,+IAAM,IAAI,CAAC;IACrB;AACR;AAEO,SAAS,gBAAgB,KAAK,EAAE,KAAK,EAAE,GAAG;IAC7C,IAAI,OAAO,UAAU,YACjB,OAAO,QAAQ,YACf,+IAAM,IAAI,CAAC,WAAW,MAAM,OAAO;QACnC,MAAM,IAAI,+IAAM,2BAA2B,CAAC;YACxC,QAAQ;YACR,UAAU;YACV,MAAM,+IAAM,IAAI,CAAC;QACrB;IACJ;AACJ;AAEO,MAAM,cAAc;IACvB,MAAM;IACN,MAAM;IACN,GAAG;IACH,GAAG;IACH,GAAG;IACH,GAAG;AACP;AAEO,SAAS,iBAAiB,IAAI;IACjC,IAAI,QAAQ,YAAY,IAAI,IAAI,QAAQ,YAAY,IAAI,EACpD,OAAO,OAAO,YAAY,IAAI;IAClC,IAAI,QAAQ,YAAY,CAAC,IAAI,QAAQ,YAAY,CAAC,EAC9C,OAAO,OAAO,CAAC,YAAY,CAAC,GAAG,EAAE;IACrC,IAAI,QAAQ,YAAY,CAAC,IAAI,QAAQ,YAAY,CAAC,EAC9C,OAAO,OAAO,CAAC,YAAY,CAAC,GAAG,EAAE;IACrC,OAAO;AACX;AAEO,SAAS,IAAI,KAAK,EAAE,UAAU,CAAC,CAAC;IACnC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE,GAAG;IAC3B,IAAI,SAAS,GACT,OAAO;IACX,IAAI,MAAM,MAAM,GAAG,MACf,MAAM,IAAI,+IAAM,2BAA2B,CAAC;QACxC,MAAM,MAAM,MAAM;QAClB,YAAY;QACZ,MAAM;IACV;IACJ,MAAM,cAAc,IAAI,WAAW;IACnC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,IAAK;QAC3B,MAAM,SAAS,QAAQ;QACvB,WAAW,CAAC,SAAS,IAAI,OAAO,IAAI,EAAE,GAClC,KAAK,CAAC,SAAS,IAAI,MAAM,MAAM,GAAG,IAAI,EAAE;IAChD;IACA,OAAO;AACX;AAEO,SAAS,KAAK,KAAK,EAAE,UAAU,CAAC,CAAC;IACpC,MAAM,EAAE,MAAM,MAAM,EAAE,GAAG;IACzB,IAAI,OAAO;IACX,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,GAAG,GAAG,IAAK;QACtC,IAAI,IAAI,CAAC,QAAQ,SAAS,IAAI,KAAK,MAAM,GAAG,IAAI,EAAE,CAAC,QAAQ,OAAO,KAC9D;aAEA;IACR;IACA,OACI,QAAQ,SACF,KAAK,KAAK,CAAC,eACX,KAAK,KAAK,CAAC,GAAG,KAAK,MAAM,GAAG;IACtC,OAAO;AACX,EACA,iCAAiC"}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 572, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Hex.js"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Json from './Json.js';\nimport * as internal_bytes from './internal/bytes.js';\nimport * as internal from './internal/hex.js';\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        internal.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        internal.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA, hexB) {\n    return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length) {\n    return fromBytes(Bytes.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        internal.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex, options = {}) {\n    if (options.size)\n        internal.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex, options = {}) {\n    return Bytes.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = Bytes.fromHex(hex);\n    if (size) {\n        internal_bytes.assertSize(bytes, size);\n        bytes = Bytes.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 872, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 877, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Withdrawal.js"],"sourcesContent":["import * as Hex from './Hex.js';\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */\nexport function fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */\nexport function toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: Hex.fromNumber(withdrawal.amount),\n        index: Hex.fromNumber(withdrawal.index),\n        validatorIndex: Hex.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map"],"names":[],"mappings":";;;;;;;AAyBO,SAAS,QAAQ,UAAU;IAC9B,OAAO;QACH,GAAG,UAAU;QACb,QAAQ,OAAO,WAAW,MAAM;QAChC,OAAO,OAAO,WAAW,KAAK;QAC9B,gBAAgB,OAAO,WAAW,cAAc;IACpD;AACJ;AAyBO,SAAS,MAAM,UAAU;IAC5B,OAAO;QACH,SAAS,WAAW,OAAO;QAC3B,QAAQ,6IAAI,UAAU,CAAC,WAAW,MAAM;QACxC,OAAO,6IAAI,UAAU,CAAC,WAAW,KAAK;QACtC,gBAAgB,6IAAI,UAAU,CAAC,WAAW,cAAc;IAC5D;AACJ,EACA,sCAAsC"}},
    {"offset": {"line": 900, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/BlockOverrides.js"],"sourcesContent":["import * as Hex from './Hex.js';\nimport * as Withdrawal from './Withdrawal.js';\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */\nexport function fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(Withdrawal.fromRpc),\n        }),\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */\nexport function toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: Hex.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: Hex.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: Hex.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: Hex.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: Hex.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: Hex.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(Withdrawal.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map"],"names":[],"mappings":";;;;;;;;;AA+BO,SAAS,QAAQ,iBAAiB;IACrC,OAAO;QACH,GAAI,kBAAkB,aAAa,IAAI;YACnC,eAAe,OAAO,kBAAkB,aAAa;QACzD,CAAC;QACD,GAAI,kBAAkB,WAAW,IAAI;YACjC,aAAa,OAAO,kBAAkB,WAAW;QACrD,CAAC;QACD,GAAI,kBAAkB,YAAY,IAAI;YAClC,cAAc,kBAAkB,YAAY;QAChD,CAAC;QACD,GAAI,kBAAkB,QAAQ,IAAI;YAC9B,UAAU,OAAO,kBAAkB,QAAQ;QAC/C,CAAC;QACD,GAAI,kBAAkB,MAAM,IAAI;YAC5B,QAAQ,OAAO,kBAAkB,MAAM;QAC3C,CAAC;QACD,GAAI,kBAAkB,UAAU,IAAI;YAChC,YAAY,OAAO,kBAAkB,UAAU;QACnD,CAAC;QACD,GAAI,kBAAkB,IAAI,IAAI;YAC1B,MAAM,OAAO,kBAAkB,IAAI;QACvC,CAAC;QACD,GAAI,kBAAkB,WAAW,IAAI;YACjC,aAAa,kBAAkB,WAAW,CAAC,GAAG,CAAC,oJAAW,OAAO;QACrE,CAAC;IACL;AACJ;AA8BO,SAAS,MAAM,cAAc;IAChC,OAAO;QACH,GAAI,OAAO,eAAe,aAAa,KAAK,YAAY;YACpD,eAAe,6IAAI,UAAU,CAAC,eAAe,aAAa;QAC9D,CAAC;QACD,GAAI,OAAO,eAAe,WAAW,KAAK,YAAY;YAClD,aAAa,6IAAI,UAAU,CAAC,eAAe,WAAW;QAC1D,CAAC;QACD,GAAI,OAAO,eAAe,YAAY,KAAK,YAAY;YACnD,cAAc,eAAe,YAAY;QAC7C,CAAC;QACD,GAAI,OAAO,eAAe,QAAQ,KAAK,YAAY;YAC/C,UAAU,6IAAI,UAAU,CAAC,eAAe,QAAQ;QACpD,CAAC;QACD,GAAI,OAAO,eAAe,MAAM,KAAK,YAAY;YAC7C,QAAQ,6IAAI,UAAU,CAAC,eAAe,MAAM;QAChD,CAAC;QACD,GAAI,OAAO,eAAe,UAAU,KAAK,YAAY;YACjD,YAAY,6IAAI,UAAU,CAAC,eAAe,UAAU;QACxD,CAAC;QACD,GAAI,OAAO,eAAe,IAAI,KAAK,YAAY;YAC3C,MAAM,6IAAI,UAAU,CAAC,eAAe,IAAI;QAC5C,CAAC;QACD,GAAI,eAAe,WAAW,IAAI;YAC9B,aAAa,eAAe,WAAW,CAAC,GAAG,CAAC,oJAAW,KAAK;QAChE,CAAC;IACL;AACJ,EACA,0CAA0C"}},
    {"offset": {"line": 970, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 975, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Json.js"],"sourcesContent":["const bigIntSuffix = '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nexport function parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nexport function stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map"],"names":[],"mappings":";;;;AAAA,MAAM,eAAe;AAmBd,SAAS,MAAM,MAAM,EAAE,OAAO;IACjC,OAAO,KAAK,KAAK,CAAC,QAAQ,CAAC,KAAK;QAC5B,MAAM,QAAQ;QACd,IAAI,OAAO,UAAU,YAAY,MAAM,QAAQ,CAAC,eAC5C,OAAO,OAAO,MAAM,KAAK,CAAC,GAAG,CAAC,aAAa,MAAM;QACrD,OAAO,OAAO,YAAY,aAAa,QAAQ,KAAK,SAAS;IACjE;AACJ;AAoBO,SAAS,UAAU,KAAK,EAAE,QAAQ,EAAE,KAAK;IAC5C,OAAO,KAAK,SAAS,CAAC,OAAO,CAAC,KAAK;QAC/B,IAAI,OAAO,aAAa,YACpB,OAAO,SAAS,KAAK;QACzB,IAAI,OAAO,UAAU,UACjB,OAAO,MAAM,QAAQ,KAAK;QAC9B,OAAO;IACX,GAAG;AACP,EACA,gCAAgC"}},
    {"offset": {"line": 994, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 999, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/internal/hex.js"],"sourcesContent":["import * as Hex from '../Hex.js';\n/** @internal */\nexport function assertSize(hex, size_) {\n    if (Hex.size(hex) > size_)\n        throw new Hex.SizeOverflowError({\n            givenSize: Hex.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1)\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Hex.size(value),\n        });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Hex.size(value) !== end - start) {\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Hex.size(value),\n        });\n    }\n}\n/** @internal */\nexport function pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new Hex.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nexport function trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map"],"names":[],"mappings":";;;;;;;;;;AAEO,SAAS,WAAW,GAAG,EAAE,KAAK;IACjC,IAAI,qKAAI,IAAI,CAAC,OAAO,OAChB,MAAM,IAAI,qKAAI,iBAAiB,CAAC;QAC5B,WAAW,qKAAI,IAAI,CAAC;QACpB,SAAS;IACb;AACR;AAEO,SAAS,kBAAkB,KAAK,EAAE,KAAK;IAC1C,IAAI,OAAO,UAAU,YAAY,QAAQ,KAAK,QAAQ,qKAAI,IAAI,CAAC,SAAS,GACpE,MAAM,IAAI,qKAAI,2BAA2B,CAAC;QACtC,QAAQ;QACR,UAAU;QACV,MAAM,qKAAI,IAAI,CAAC;IACnB;AACR;AAEO,SAAS,gBAAgB,KAAK,EAAE,KAAK,EAAE,GAAG;IAC7C,IAAI,OAAO,UAAU,YACjB,OAAO,QAAQ,YACf,qKAAI,IAAI,CAAC,WAAW,MAAM,OAAO;QACjC,MAAM,IAAI,qKAAI,2BAA2B,CAAC;YACtC,QAAQ;YACR,UAAU;YACV,MAAM,qKAAI,IAAI,CAAC;QACnB;IACJ;AACJ;AAEO,SAAS,IAAI,IAAI,EAAE,UAAU,CAAC,CAAC;IAClC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE,GAAG;IAC3B,IAAI,SAAS,GACT,OAAO;IACX,MAAM,MAAM,KAAK,OAAO,CAAC,MAAM;IAC/B,IAAI,IAAI,MAAM,GAAG,OAAO,GACpB,MAAM,IAAI,qKAAI,2BAA2B,CAAC;QACtC,MAAM,KAAK,IAAI,CAAC,IAAI,MAAM,GAAG;QAC7B,YAAY;QACZ,MAAM;IACV;IACJ,OAAO,CAAC,EAAE,EAAE,GAAG,CAAC,QAAQ,UAAU,WAAW,WAAW,CAAC,OAAO,GAAG,KAAK,CAAC;AAC7E;AAEO,SAAS,KAAK,KAAK,EAAE,UAAU,CAAC,CAAC;IACpC,MAAM,EAAE,MAAM,MAAM,EAAE,GAAG;IACzB,IAAI,OAAO,MAAM,OAAO,CAAC,MAAM;IAC/B,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,GAAG,GAAG,IAAK;QACtC,IAAI,IAAI,CAAC,QAAQ,SAAS,IAAI,KAAK,MAAM,GAAG,IAAI,EAAE,CAAC,QAAQ,OAAO,KAC9D;aAEA;IACR;IACA,OACI,QAAQ,SACF,KAAK,KAAK,CAAC,eACX,KAAK,KAAK,CAAC,GAAG,KAAK,MAAM,GAAG;IACtC,IAAI,SAAS,KACT,OAAO;IACX,IAAI,QAAQ,WAAW,KAAK,MAAM,GAAG,MAAM,GACvC,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;IACvB,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC;AACtB,EACA,+BAA+B"}},
    {"offset": {"line": 1055, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1060, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/version.js"],"sourcesContent":["/** @internal */\nexport const version = '0.1.1';\n//# sourceMappingURL=version.js.map"],"names":[],"mappings":"AAAA,cAAc;;;AACP,MAAM,UAAU,SACvB,mCAAmC"}},
    {"offset": {"line": 1064, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1069, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/internal/errors.js"],"sourcesContent":["import { version } from '../version.js';\n/** @internal */\nexport function getUrl(url) {\n    return url;\n}\n/** @internal */\nexport function getVersion() {\n    return version;\n}\n/** @internal */\nexport function prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map"],"names":[],"mappings":";;;;;;;;AAEO,SAAS,OAAO,GAAG;IACtB,OAAO;AACX;AAEO,SAAS;IACZ;AACJ;AAEO,SAAS,YAAY,IAAI;IAC5B,IAAI,CAAC,MACD,OAAO;IACX,MAAM,UAAU,OAAO,OAAO,CAAC,MAC1B,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM;QAClB,IAAI,UAAU,aAAa,UAAU,OACjC,OAAO;QACX,OAAO;YAAC;YAAK;SAAM;IACvB,GACK,MAAM,CAAC;IACZ,MAAM,YAAY,QAAQ,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,GAAK,KAAK,GAAG,CAAC,KAAK,IAAI,MAAM,GAAG;IAC5E,OAAO,QACF,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM,GAAK,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,GAAG,EAAE,EAAE,MAAM,CAAC,EACtE,IAAI,CAAC;AACd,EACA,kCAAkC"}},
    {"offset": {"line": 1095, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1100, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Errors.js"],"sourcesContent":["import { getVersion } from './internal/errors.js';\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nexport class BaseError extends Error {\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause &&\n                'details' in options.cause &&\n                typeof options.cause.details === 'string')\n                return options.cause.details;\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = 'https://oxlib.sh';\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: `ox@${getVersion()}`\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map"],"names":[],"mappings":";;;;;;AAUO,MAAM,kBAAkB;IAC3B,YAAY,YAAY,EAAE,UAAU,CAAC,CAAC,CAAE;QACpC,MAAM,UAAU,AAAC,CAAA;YACb,IAAI,QAAQ,KAAK,YAAY,WAAW;gBACpC,IAAI,QAAQ,KAAK,CAAC,OAAO,EACrB,OAAO,QAAQ,KAAK,CAAC,OAAO;gBAChC,IAAI,QAAQ,KAAK,CAAC,YAAY,EAC1B,OAAO,QAAQ,KAAK,CAAC,YAAY;YACzC;YACA,IAAI,QAAQ,KAAK,IACb,aAAa,QAAQ,KAAK,IAC1B,OAAO,QAAQ,KAAK,CAAC,OAAO,KAAK,UACjC,OAAO,QAAQ,KAAK,CAAC,OAAO;YAChC,IAAI,QAAQ,KAAK,EAAE,SACf,OAAO,QAAQ,KAAK,CAAC,OAAO;YAChC,OAAO,QAAQ,OAAO;QAC1B,CAAA;QACA,MAAM,WAAW,AAAC,CAAA;YACd,IAAI,QAAQ,KAAK,YAAY,WACzB,OAAO,QAAQ,KAAK,CAAC,QAAQ,IAAI,QAAQ,QAAQ;YACrD,OAAO,QAAQ,QAAQ;QAC3B,CAAA;QACA,MAAM,cAAc;QACpB,MAAM,OAAO,CAAC,EAAE,YAAY,EAAE,YAAY,GAAG,CAAC;QAC9C,MAAM,UAAU;YACZ,gBAAgB;eACZ,QAAQ,YAAY,GAAG;gBAAC;mBAAO,QAAQ,YAAY;aAAC,GAAG,EAAE;eACzD,WAAW,WACT;gBACE;gBACA,UAAU,CAAC,SAAS,EAAE,QAAQ,CAAC,GAAG;gBAClC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG;aAC/B,GACC,EAAE;SACX,CACI,MAAM,CAAC,CAAC,IAAM,OAAO,MAAM,UAC3B,IAAI,CAAC;QACV,KAAK,CAAC,SAAS,QAAQ,KAAK,GAAG;YAAE,OAAO,QAAQ,KAAK;QAAC,IAAI;QAC1D,OAAO,cAAc,CAAC,IAAI,EAAE,WAAW;YACnC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,YAAY;YACpC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB;YACxC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,SAAS;YACjC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,WAAW;YACnC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,CAAC,GAAG,EAAE,oMAAa,CAAC;QAC/B;QACA,IAAI,CAAC,KAAK,GAAG,QAAQ,KAAK;QAC1B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;IACxB;IACA,KAAK,EAAE,EAAE;QACL,OAAO,KAAK,IAAI,EAAE;IACtB;AACJ;AACA,cAAc,GACd,SAAS,KAAK,GAAG,EAAE,EAAE;IACjB,IAAI,KAAK,MACL,OAAO;IACX,IAAI,OAAO,OAAO,QAAQ,YAAY,WAAW,OAAO,IAAI,KAAK,EAC7D,OAAO,KAAK,IAAI,KAAK,EAAE;IAC3B,OAAO,KAAK,OAAO;AACvB,EACA,kCAAkC"}},
    {"offset": {"line": 1195, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1200, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Bytes.js"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/bytes.js';\nimport * as internal_hex from './internal/hex.js';\nimport * as Json from './Json.js';\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nexport function assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nexport function concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        internal_hex.assertSize(value, size);\n        hex = Hex.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new Errors.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromNumber(value, options) {\n    const hex = Hex.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nexport function isEqual(bytesA, bytesB) {\n    return equalBytes(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nexport function random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nexport function size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nexport function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nexport function toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nexport function toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value, options = {}) {\n    return Hex.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nexport function toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nexport function toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nexport function validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nexport class InvalidBytesBooleanError extends Errors.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nexport class InvalidBytesTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1459, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1464, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/internal/bytes.js"],"sourcesContent":["import * as Bytes from '../Bytes.js';\n/** @internal */\nexport function assertSize(bytes, size_) {\n    if (Bytes.size(bytes) > size_)\n        throw new Bytes.SizeOverflowError({\n            givenSize: Bytes.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Bytes.size(value),\n        });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Bytes.size(value) !== end - start) {\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Bytes.size(value),\n        });\n    }\n}\n/** @internal */\nexport const charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nexport function charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nexport function pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new Bytes.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nexport function trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAEO,SAAS,WAAW,KAAK,EAAE,KAAK;IACnC,IAAI,uKAAM,IAAI,CAAC,SAAS,OACpB,MAAM,IAAI,uKAAM,iBAAiB,CAAC;QAC9B,WAAW,uKAAM,IAAI,CAAC;QACtB,SAAS;IACb;AACR;AAEO,SAAS,kBAAkB,KAAK,EAAE,KAAK;IAC1C,IAAI,OAAO,UAAU,YAAY,QAAQ,KAAK,QAAQ,uKAAM,IAAI,CAAC,SAAS,GACtE,MAAM,IAAI,uKAAM,2BAA2B,CAAC;QACxC,QAAQ;QACR,UAAU;QACV,MAAM,uKAAM,IAAI,CAAC;IACrB;AACR;AAEO,SAAS,gBAAgB,KAAK,EAAE,KAAK,EAAE,GAAG;IAC7C,IAAI,OAAO,UAAU,YACjB,OAAO,QAAQ,YACf,uKAAM,IAAI,CAAC,WAAW,MAAM,OAAO;QACnC,MAAM,IAAI,uKAAM,2BAA2B,CAAC;YACxC,QAAQ;YACR,UAAU;YACV,MAAM,uKAAM,IAAI,CAAC;QACrB;IACJ;AACJ;AAEO,MAAM,cAAc;IACvB,MAAM;IACN,MAAM;IACN,GAAG;IACH,GAAG;IACH,GAAG;IACH,GAAG;AACP;AAEO,SAAS,iBAAiB,IAAI;IACjC,IAAI,QAAQ,YAAY,IAAI,IAAI,QAAQ,YAAY,IAAI,EACpD,OAAO,OAAO,YAAY,IAAI;IAClC,IAAI,QAAQ,YAAY,CAAC,IAAI,QAAQ,YAAY,CAAC,EAC9C,OAAO,OAAO,CAAC,YAAY,CAAC,GAAG,EAAE;IACrC,IAAI,QAAQ,YAAY,CAAC,IAAI,QAAQ,YAAY,CAAC,EAC9C,OAAO,OAAO,CAAC,YAAY,CAAC,GAAG,EAAE;IACrC,OAAO;AACX;AAEO,SAAS,IAAI,KAAK,EAAE,UAAU,CAAC,CAAC;IACnC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE,GAAG;IAC3B,IAAI,SAAS,GACT,OAAO;IACX,IAAI,MAAM,MAAM,GAAG,MACf,MAAM,IAAI,uKAAM,2BAA2B,CAAC;QACxC,MAAM,MAAM,MAAM;QAClB,YAAY;QACZ,MAAM;IACV;IACJ,MAAM,cAAc,IAAI,WAAW;IACnC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,IAAK;QAC3B,MAAM,SAAS,QAAQ;QACvB,WAAW,CAAC,SAAS,IAAI,OAAO,IAAI,EAAE,GAClC,KAAK,CAAC,SAAS,IAAI,MAAM,MAAM,GAAG,IAAI,EAAE;IAChD;IACA,OAAO;AACX;AAEO,SAAS,KAAK,KAAK,EAAE,UAAU,CAAC,CAAC;IACpC,MAAM,EAAE,MAAM,MAAM,EAAE,GAAG;IACzB,IAAI,OAAO;IACX,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,GAAG,GAAG,IAAK;QACtC,IAAI,IAAI,CAAC,QAAQ,SAAS,IAAI,KAAK,MAAM,GAAG,IAAI,EAAE,CAAC,QAAQ,OAAO,KAC9D;aAEA;IACR;IACA,OACI,QAAQ,SACF,KAAK,KAAK,CAAC,eACX,KAAK,KAAK,CAAC,GAAG,KAAK,MAAM,GAAG;IACtC,OAAO;AACX,EACA,iCAAiC"}},
    {"offset": {"line": 1538, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1543, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Hex.js"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as internal_bytes from './internal/bytes.js';\nimport * as internal from './internal/hex.js';\nimport * as Json from './Json.js';\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        internal.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        internal.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA, hexB) {\n    return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length) {\n    return fromBytes(Bytes.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        internal.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex, options = {}) {\n    if (options.size)\n        internal.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex, options = {}) {\n    return Bytes.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = Bytes.fromHex(hex);\n    if (size) {\n        internal_bytes.assertSize(bytes, size);\n        bytes = Bytes.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1843, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1848, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Withdrawal.js"],"sourcesContent":["import * as Hex from './Hex.js';\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */\nexport function fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */\nexport function toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: Hex.fromNumber(withdrawal.amount),\n        index: Hex.fromNumber(withdrawal.index),\n        validatorIndex: Hex.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map"],"names":[],"mappings":";;;;;;;AAyBO,SAAS,QAAQ,UAAU;IAC9B,OAAO;QACH,GAAG,UAAU;QACb,QAAQ,OAAO,WAAW,MAAM;QAChC,OAAO,OAAO,WAAW,KAAK;QAC9B,gBAAgB,OAAO,WAAW,cAAc;IACpD;AACJ;AAyBO,SAAS,MAAM,UAAU;IAC5B,OAAO;QACH,SAAS,WAAW,OAAO;QAC3B,QAAQ,qKAAI,UAAU,CAAC,WAAW,MAAM;QACxC,OAAO,qKAAI,UAAU,CAAC,WAAW,KAAK;QACtC,gBAAgB,qKAAI,UAAU,CAAC,WAAW,cAAc;IAC5D;AACJ,EACA,sCAAsC"}},
    {"offset": {"line": 1871, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1876, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/BlockOverrides.js"],"sourcesContent":["import * as Hex from './Hex.js';\nimport * as Withdrawal from './Withdrawal.js';\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */\nexport function fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(Withdrawal.fromRpc),\n        }),\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */\nexport function toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: Hex.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: Hex.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: Hex.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: Hex.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: Hex.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: Hex.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(Withdrawal.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map"],"names":[],"mappings":";;;;;;;;;AA+BO,SAAS,QAAQ,iBAAiB;IACrC,OAAO;QACH,GAAI,kBAAkB,aAAa,IAAI;YACnC,eAAe,OAAO,kBAAkB,aAAa;QACzD,CAAC;QACD,GAAI,kBAAkB,WAAW,IAAI;YACjC,aAAa,OAAO,kBAAkB,WAAW;QACrD,CAAC;QACD,GAAI,kBAAkB,YAAY,IAAI;YAClC,cAAc,kBAAkB,YAAY;QAChD,CAAC;QACD,GAAI,kBAAkB,QAAQ,IAAI;YAC9B,UAAU,OAAO,kBAAkB,QAAQ;QAC/C,CAAC;QACD,GAAI,kBAAkB,MAAM,IAAI;YAC5B,QAAQ,OAAO,kBAAkB,MAAM;QAC3C,CAAC;QACD,GAAI,kBAAkB,UAAU,IAAI;YAChC,YAAY,OAAO,kBAAkB,UAAU;QACnD,CAAC;QACD,GAAI,kBAAkB,IAAI,IAAI;YAC1B,MAAM,OAAO,kBAAkB,IAAI;QACvC,CAAC;QACD,GAAI,kBAAkB,WAAW,IAAI;YACjC,aAAa,kBAAkB,WAAW,CAAC,GAAG,CAAC,4KAAW,OAAO;QACrE,CAAC;IACL;AACJ;AA8BO,SAAS,MAAM,cAAc;IAChC,OAAO;QACH,GAAI,OAAO,eAAe,aAAa,KAAK,YAAY;YACpD,eAAe,qKAAI,UAAU,CAAC,eAAe,aAAa;QAC9D,CAAC;QACD,GAAI,OAAO,eAAe,WAAW,KAAK,YAAY;YAClD,aAAa,qKAAI,UAAU,CAAC,eAAe,WAAW;QAC1D,CAAC;QACD,GAAI,OAAO,eAAe,YAAY,KAAK,YAAY;YACnD,cAAc,eAAe,YAAY;QAC7C,CAAC;QACD,GAAI,OAAO,eAAe,QAAQ,KAAK,YAAY;YAC/C,UAAU,qKAAI,UAAU,CAAC,eAAe,QAAQ;QACpD,CAAC;QACD,GAAI,OAAO,eAAe,MAAM,KAAK,YAAY;YAC7C,QAAQ,qKAAI,UAAU,CAAC,eAAe,MAAM;QAChD,CAAC;QACD,GAAI,OAAO,eAAe,UAAU,KAAK,YAAY;YACjD,YAAY,qKAAI,UAAU,CAAC,eAAe,UAAU;QACxD,CAAC;QACD,GAAI,OAAO,eAAe,IAAI,KAAK,YAAY;YAC3C,MAAM,qKAAI,UAAU,CAAC,eAAe,IAAI;QAC5C,CAAC;QACD,GAAI,eAAe,WAAW,IAAI;YAC9B,aAAa,eAAe,WAAW,CAAC,GAAG,CAAC,4KAAW,KAAK;QAChE,CAAC;IACL;AACJ,EACA,0CAA0C"}},
    {"offset": {"line": 1941, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1946, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Solidity.js"],"sourcesContent":["export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const maxInt8 = 2n ** (8n - 1n) - 1n;\nexport const maxInt16 = 2n ** (16n - 1n) - 1n;\nexport const maxInt24 = 2n ** (24n - 1n) - 1n;\nexport const maxInt32 = 2n ** (32n - 1n) - 1n;\nexport const maxInt40 = 2n ** (40n - 1n) - 1n;\nexport const maxInt48 = 2n ** (48n - 1n) - 1n;\nexport const maxInt56 = 2n ** (56n - 1n) - 1n;\nexport const maxInt64 = 2n ** (64n - 1n) - 1n;\nexport const maxInt72 = 2n ** (72n - 1n) - 1n;\nexport const maxInt80 = 2n ** (80n - 1n) - 1n;\nexport const maxInt88 = 2n ** (88n - 1n) - 1n;\nexport const maxInt96 = 2n ** (96n - 1n) - 1n;\nexport const maxInt104 = 2n ** (104n - 1n) - 1n;\nexport const maxInt112 = 2n ** (112n - 1n) - 1n;\nexport const maxInt120 = 2n ** (120n - 1n) - 1n;\nexport const maxInt128 = 2n ** (128n - 1n) - 1n;\nexport const maxInt136 = 2n ** (136n - 1n) - 1n;\nexport const maxInt144 = 2n ** (144n - 1n) - 1n;\nexport const maxInt152 = 2n ** (152n - 1n) - 1n;\nexport const maxInt160 = 2n ** (160n - 1n) - 1n;\nexport const maxInt168 = 2n ** (168n - 1n) - 1n;\nexport const maxInt176 = 2n ** (176n - 1n) - 1n;\nexport const maxInt184 = 2n ** (184n - 1n) - 1n;\nexport const maxInt192 = 2n ** (192n - 1n) - 1n;\nexport const maxInt200 = 2n ** (200n - 1n) - 1n;\nexport const maxInt208 = 2n ** (208n - 1n) - 1n;\nexport const maxInt216 = 2n ** (216n - 1n) - 1n;\nexport const maxInt224 = 2n ** (224n - 1n) - 1n;\nexport const maxInt232 = 2n ** (232n - 1n) - 1n;\nexport const maxInt240 = 2n ** (240n - 1n) - 1n;\nexport const maxInt248 = 2n ** (248n - 1n) - 1n;\nexport const maxInt256 = 2n ** (256n - 1n) - 1n;\nexport const minInt8 = -(2n ** (8n - 1n));\nexport const minInt16 = -(2n ** (16n - 1n));\nexport const minInt24 = -(2n ** (24n - 1n));\nexport const minInt32 = -(2n ** (32n - 1n));\nexport const minInt40 = -(2n ** (40n - 1n));\nexport const minInt48 = -(2n ** (48n - 1n));\nexport const minInt56 = -(2n ** (56n - 1n));\nexport const minInt64 = -(2n ** (64n - 1n));\nexport const minInt72 = -(2n ** (72n - 1n));\nexport const minInt80 = -(2n ** (80n - 1n));\nexport const minInt88 = -(2n ** (88n - 1n));\nexport const minInt96 = -(2n ** (96n - 1n));\nexport const minInt104 = -(2n ** (104n - 1n));\nexport const minInt112 = -(2n ** (112n - 1n));\nexport const minInt120 = -(2n ** (120n - 1n));\nexport const minInt128 = -(2n ** (128n - 1n));\nexport const minInt136 = -(2n ** (136n - 1n));\nexport const minInt144 = -(2n ** (144n - 1n));\nexport const minInt152 = -(2n ** (152n - 1n));\nexport const minInt160 = -(2n ** (160n - 1n));\nexport const minInt168 = -(2n ** (168n - 1n));\nexport const minInt176 = -(2n ** (176n - 1n));\nexport const minInt184 = -(2n ** (184n - 1n));\nexport const minInt192 = -(2n ** (192n - 1n));\nexport const minInt200 = -(2n ** (200n - 1n));\nexport const minInt208 = -(2n ** (208n - 1n));\nexport const minInt216 = -(2n ** (216n - 1n));\nexport const minInt224 = -(2n ** (224n - 1n));\nexport const minInt232 = -(2n ** (232n - 1n));\nexport const minInt240 = -(2n ** (240n - 1n));\nexport const minInt248 = -(2n ** (248n - 1n));\nexport const minInt256 = -(2n ** (256n - 1n));\nexport const maxUint8 = 2n ** 8n - 1n;\nexport const maxUint16 = 2n ** 16n - 1n;\nexport const maxUint24 = 2n ** 24n - 1n;\nexport const maxUint32 = 2n ** 32n - 1n;\nexport const maxUint40 = 2n ** 40n - 1n;\nexport const maxUint48 = 2n ** 48n - 1n;\nexport const maxUint56 = 2n ** 56n - 1n;\nexport const maxUint64 = 2n ** 64n - 1n;\nexport const maxUint72 = 2n ** 72n - 1n;\nexport const maxUint80 = 2n ** 80n - 1n;\nexport const maxUint88 = 2n ** 88n - 1n;\nexport const maxUint96 = 2n ** 96n - 1n;\nexport const maxUint104 = 2n ** 104n - 1n;\nexport const maxUint112 = 2n ** 112n - 1n;\nexport const maxUint120 = 2n ** 120n - 1n;\nexport const maxUint128 = 2n ** 128n - 1n;\nexport const maxUint136 = 2n ** 136n - 1n;\nexport const maxUint144 = 2n ** 144n - 1n;\nexport const maxUint152 = 2n ** 152n - 1n;\nexport const maxUint160 = 2n ** 160n - 1n;\nexport const maxUint168 = 2n ** 168n - 1n;\nexport const maxUint176 = 2n ** 176n - 1n;\nexport const maxUint184 = 2n ** 184n - 1n;\nexport const maxUint192 = 2n ** 192n - 1n;\nexport const maxUint200 = 2n ** 200n - 1n;\nexport const maxUint208 = 2n ** 208n - 1n;\nexport const maxUint216 = 2n ** 216n - 1n;\nexport const maxUint224 = 2n ** 224n - 1n;\nexport const maxUint232 = 2n ** 232n - 1n;\nexport const maxUint240 = 2n ** 240n - 1n;\nexport const maxUint248 = 2n ** 248n - 1n;\nexport const maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map"],"names":[],"mappings":"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AI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,WAAW,EAAE,IAAI,EAAE,GAAG,EAAE;AAC9B,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE,EACzC,oCAAoC"}},
    {"offset": {"line": 2146, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2151, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Signature.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\nimport * as Solidity from './Solidity.js';\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (typeof signature.s === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (recovered && typeof signature.yParity === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (signature.r < 0n || signature.r > Solidity.maxUint256)\n        throw new InvalidRError({ value: signature.r });\n    if (signature.s < 0n || signature.s > Solidity.maxUint256)\n        throw new InvalidSError({ value: signature.s });\n    if (typeof signature.yParity === 'number' &&\n        signature.yParity !== 0 &&\n        signature.yParity !== 1)\n        throw new InvalidYParityError({ value: signature.yParity });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature) {\n    return fromHex(Hex.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132)\n        throw new InvalidSerializedSizeError({ signature });\n    const r = BigInt(Hex.slice(signature, 0, 32));\n    const s = BigInt(Hex.slice(signature, 32, 64));\n    const yParity = (() => {\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity))\n            return undefined;\n        try {\n            return vToYParity(yParity);\n        }\n        catch {\n            throw new InvalidYParityError({ value: yParity });\n        }\n    })();\n    if (typeof yParity === 'undefined')\n        return {\n            r,\n            s,\n        };\n    return {\n        r,\n        s,\n        yParity,\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value) {\n    if (typeof value.r === 'undefined')\n        return undefined;\n    if (typeof value.s === 'undefined')\n        return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from(signature) {\n    const signature_ = (() => {\n        if (typeof signature === 'string')\n            return fromHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature);\n        if (typeof signature.r === 'string')\n            return fromRpc(signature);\n        if (signature.v)\n            return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...(typeof signature.yParity !== 'undefined'\n                ? { yParity: signature.yParity }\n                : {}),\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature) {\n    return fromDerHex(Hex.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature) {\n    const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2));\n    return { r, s };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature) {\n    const yParity = (() => {\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === 'number' && typeof yParity !== 'number')\n            yParity = vToYParity(v);\n        if (typeof yParity !== 'number')\n            throw new InvalidYParityError({ value: signature.yParity });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity,\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === '0x' ? 0n : BigInt(r),\n        s: s === '0x' ? 0n : BigInt(s),\n        yParity: yParity === '0x' ? 0 : Number(yParity),\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature) {\n    return Bytes.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = Hex.concat(Hex.fromNumber(r, { size: 32 }), Hex.fromNumber(s, { size: 32 }), \n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n        ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n        : '0x');\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature) {\n    const sig = new secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature) {\n    const sig = new secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: Hex.fromNumber(r, { size: 32 }),\n        s: Hex.fromNumber(s, { size: 32 }),\n        yParity: yParity === 0 ? '0x0' : '0x1',\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? '0x01' : '0x',\n        r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r)),\n        s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s)),\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v) {\n    if (v === 0 || v === 27)\n        return 0;\n    if (v === 1 || v === 28)\n        return 1;\n    if (v >= 35)\n        return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({ value: v });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity) {\n    if (yParity === 0)\n        return 27;\n    if (yParity === 1)\n        return 28;\n    throw new InvalidYParityError({ value: yParity });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n    constructor({ signature }) {\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                'Expected: 64 bytes or 65 bytes.',\n                `Received ${Hex.size(Hex.from(signature))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSerializedSizeError'\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n    constructor({ signature }) {\n        super(`Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.MissingPropertiesError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidRError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidYParityError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidVError'\n        });\n    }\n}\n//# sourceMappingURL=Signature.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2452, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2457, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/PublicKey.js"],"sourcesContent":["import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false ||\n        (typeof x === 'bigint' && typeof y === 'bigint')) {\n        if (prefix !== 4)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidUncompressedPrefixError(),\n            });\n        return;\n    }\n    // Compressed\n    if (compressed === true ||\n        (typeof x === 'bigint' && typeof y === 'undefined')) {\n        if (prefix !== 3 && prefix !== 2)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidCompressedPrefixError(),\n            });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({ publicKey });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport function compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x,\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nexport function from(value) {\n    const publicKey = (() => {\n        if (Hex.validate(value))\n            return fromHex(value);\n        if (Bytes.validate(value))\n            return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === 'bigint' && typeof y === 'bigint')\n            return { prefix: prefix ?? 0x04, x, y };\n        return { prefix, x };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromBytes(publicKey) {\n    return fromHex(Hex.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromHex(publicKey) {\n    if (publicKey.length !== 132 &&\n        publicKey.length !== 130 &&\n        publicKey.length !== 68)\n        throw new InvalidSerializedSizeError({ publicKey });\n    if (publicKey.length === 130) {\n        const x = BigInt(Hex.slice(publicKey, 0, 32));\n        const y = BigInt(Hex.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y,\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(Hex.slice(publicKey, 0, 1));\n        const x = BigInt(Hex.slice(publicKey, 1, 33));\n        const y = BigInt(Hex.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y,\n        };\n    }\n    const prefix = Number(Hex.slice(publicKey, 0, 1));\n    const x = BigInt(Hex.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x,\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toBytes(publicKey, options = {}) {\n    return Bytes.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = Hex.concat(includePrefix ? Hex.fromNumber(prefix, { size: 1 }) : '0x', Hex.fromNumber(x, { size: 32 }), \n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? Hex.fromNumber(y, { size: 32 }) : '0x');\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    }\n    catch (_error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nexport class InvalidError extends Errors.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                'Public key must contain:',\n                '- an `x` and `prefix` value (compressed)',\n                '- an `x`, `y`, and `prefix` value (uncompressed)',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidError'\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */\nexport class InvalidPrefixError extends Errors.BaseError {\n    constructor({ prefix, cause }) {\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nexport class InvalidCompressedPrefixError extends Errors.BaseError {\n    constructor() {\n        super('Prefix must be 2 or 3 for compressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidCompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nexport class InvalidUncompressedPrefixError extends Errors.BaseError {\n    constructor() {\n        super('Prefix must be 4 for uncompressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidUncompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n                `Received ${Hex.size(Hex.from(publicKey))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidSerializedSizeError'\n        });\n    }\n}\n//# sourceMappingURL=PublicKey.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2656, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2661, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/internal/entropy.js"],"sourcesContent":["export let extraEntropy = false;\n/** @internal */\nexport function setExtraEntropy(entropy) {\n    extraEntropy = entropy;\n}\n//# sourceMappingURL=entropy.js.map"],"names":[],"mappings":";;;;AAAO,IAAI,eAAe;AAEnB,SAAS,gBAAgB,OAAO;IACnC,eAAe;AACnB,EACA,mCAAmC"}},
    {"offset": {"line": 2669, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2674, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Hash.js"],"sourcesContent":["import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160';\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3';\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_keccak256(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_ripemd160(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_sha256(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value) {\n    return Hex.validate(value) && Hex.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AA0CO,SAAS,UAAU,KAAK,EAAE,UAAU,CAAC,CAAC;IACzC,MAAM,EAAE,KAAK,OAAO,UAAU,WAAW,QAAQ,OAAO,EAAE,GAAG;IAC7D,MAAM,QAAQ,0LAAgB,uKAAM,IAAI,CAAC;IACzC,IAAI,OAAO,SACP,OAAO;IACX,OAAO,qKAAI,SAAS,CAAC;AACzB;AAkBO,SAAS,UAAU,KAAK,EAAE,UAAU,CAAC,CAAC;IACzC,MAAM,EAAE,KAAK,OAAO,UAAU,WAAW,QAAQ,OAAO,EAAE,GAAG;IAC7D,MAAM,QAAQ,8LAAgB,uKAAM,IAAI,CAAC;IACzC,IAAI,OAAO,SACP,OAAO;IACX,OAAO,qKAAI,SAAS,CAAC;AACzB;AAkBO,SAAS,OAAO,KAAK,EAAE,UAAU,CAAC,CAAC;IACtC,MAAM,EAAE,KAAK,OAAO,UAAU,WAAW,QAAQ,OAAO,EAAE,GAAG;IAC7D,MAAM,QAAQ,wLAAa,uKAAM,IAAI,CAAC;IACtC,IAAI,OAAO,SACP,OAAO;IACX,OAAO,qKAAI,SAAS,CAAC;AACzB;AAkBO,SAAS,SAAS,KAAK;IAC1B,OAAO,qKAAI,QAAQ,CAAC,UAAU,qKAAI,IAAI,CAAC,WAAW;AACtD,EACA,gCAAgC"}},
    {"offset": {"line": 2712, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2717, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/internal/lru.js"],"sourcesContent":["/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map"],"names":[],"mappings":"AAAA;;;;;CAKC;;;AACM,MAAM,eAAe;IACxB,YAAY,IAAI,CAAE;QACd,KAAK;QACL,OAAO,cAAc,CAAC,IAAI,EAAE,WAAW;YACnC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,IAAI,GAAG,EAAE;QACL,MAAM,QAAQ,KAAK,CAAC,IAAI;QACxB,IAAI,KAAK,CAAC,IAAI,QAAQ,UAAU,WAAW;YACvC,IAAI,CAAC,MAAM,CAAC;YACZ,KAAK,CAAC,IAAI,KAAK;QACnB;QACA,OAAO;IACX;IACA,IAAI,GAAG,EAAE,KAAK,EAAE;QACZ,KAAK,CAAC,IAAI,KAAK;QACf,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE;YAC1C,MAAM,WAAW,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG,KAAK;YACzC,IAAI,UACA,IAAI,CAAC,MAAM,CAAC;QACpB;QACA,OAAO,IAAI;IACf;AACJ,EACA,+BAA+B"}},
    {"offset": {"line": 2753, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2758, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Caches.js"],"sourcesContent":["import { LruMap } from './internal/lru.js';\nconst caches = {\n    checksum: /*#__PURE__*/ new LruMap(8192),\n};\nexport const checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nexport function clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map"],"names":[],"mappings":";;;;;;;AACA,MAAM,SAAS;IACX,UAAU,WAAW,GAAG,+LAAW;AACvC;AACO,MAAM,WAAW,OAAO,QAAQ;AAUhC,SAAS;IACZ,KAAK,MAAM,SAAS,OAAO,MAAM,CAAC,QAC9B,MAAM,KAAK;AACnB,EACA,kCAAkC"}},
    {"offset": {"line": 2772, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2777, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Address.js"],"sourcesContent":["import * as Bytes from './Bytes.js';\nimport * as Caches from './Caches.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as PublicKey from './PublicKey.js';\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address) {\n    if (Caches.checksum.has(address))\n        return Caches.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    Caches.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(publicKey, options = {}) {\n    const address = Hash.keccak256(`0x${PublicKey.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError extends Errors.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\n//# sourceMappingURL=Address.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2901, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2906, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Secp256k1.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\nimport * as Entropy from './internal/entropy.js';\nimport * as PublicKey from './PublicKey.js';\n/** Re-export of noble/curves secp256k1 utilities. */\nexport const noble = secp256k1;\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair(options = {}) {\n    const { as = 'Hex' } = options;\n    const privateKey = randomPrivateKey({ as });\n    const publicKey = getPublicKey({ privateKey });\n    return {\n        privateKey: privateKey,\n        publicKey,\n    };\n}\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(options) {\n    const { privateKey } = options;\n    const point = secp256k1.ProjectivePoint.fromPrivateKey(Hex.from(privateKey).slice(2));\n    return PublicKey.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret(options) {\n    const { as = 'Hex', privateKey, publicKey } = options;\n    const point = secp256k1.ProjectivePoint.fromHex(PublicKey.toHex(publicKey).slice(2));\n    const sharedPoint = point.multiply(secp256k1.utils.normPrivateKeyToScalar(Hex.from(privateKey).slice(2)));\n    const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n    if (as === 'Hex')\n        return Hex.fromBytes(sharedSecret);\n    return sharedSecret;\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey(options = {}) {\n    const { as = 'Hex' } = options;\n    const bytes = secp256k1.utils.randomPrivateKey();\n    if (as === 'Hex')\n        return Hex.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nexport function recoverAddress(options) {\n    return Address.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const point = signature_.recoverPublicKey(Hex.from(payload).substring(2));\n    return PublicKey.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options) {\n    const { extraEntropy = Entropy.extraEntropy, hash, payload, privateKey, } = options;\n    const { r, s, recovery } = secp256k1.sign(Bytes.from(payload), Bytes.from(privateKey), {\n        extraEntropy: typeof extraEntropy === 'boolean'\n            ? extraEntropy\n            : Hex.from(extraEntropy).slice(2),\n        lowS: true,\n        ...(hash ? { prehash: true } : {}),\n    });\n    return {\n        r,\n        s,\n        yParity: recovery,\n    };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nexport function verify(options) {\n    const { address, hash, payload, publicKey, signature } = options;\n    if (address)\n        return Address.isEqual(address, recoverAddress({ payload, signature }));\n    return secp256k1.verify(signature, Bytes.from(payload), PublicKey.toBytes(publicKey), ...(hash ? [{ prehash: true, lowS: true }] : []));\n}\n//# sourceMappingURL=Secp256k1.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAOO,MAAM;AAcN,SAAS,cAAc,UAAU,CAAC,CAAC;IACtC,MAAM,EAAE,KAAK,KAAK,EAAE,GAAG;IACvB,MAAM,aAAa,iBAAiB;QAAE;IAAG;IACzC,MAAM,YAAY,aAAa;QAAE;IAAW;IAC5C,OAAO;QACH,YAAY;QACZ;IACJ;AACJ;AAcO,SAAS,aAAa,OAAO;IAChC,MAAM,EAAE,UAAU,EAAE,GAAG;IACvB,MAAM,QAAQ,8LAAU,eAAe,CAAC,cAAc,CAAC,qKAAI,IAAI,CAAC,YAAY,KAAK,CAAC;IAClF,OAAO,2KAAU,IAAI,CAAC;AAC1B;AAoBO,SAAS,gBAAgB,OAAO;IACnC,MAAM,EAAE,KAAK,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG;IAC9C,MAAM,QAAQ,8LAAU,eAAe,CAAC,OAAO,CAAC,2KAAU,KAAK,CAAC,WAAW,KAAK,CAAC;IACjF,MAAM,cAAc,MAAM,QAAQ,CAAC,8LAAU,KAAK,CAAC,sBAAsB,CAAC,qKAAI,IAAI,CAAC,YAAY,KAAK,CAAC;IACrG,MAAM,eAAe,YAAY,UAAU,CAAC,OAAO,oBAAoB;IACvE,IAAI,OAAO,OACP,OAAO,qKAAI,SAAS,CAAC;IACzB,OAAO;AACX;AAcO,SAAS,iBAAiB,UAAU,CAAC,CAAC;IACzC,MAAM,EAAE,KAAK,KAAK,EAAE,GAAG;IACvB,MAAM,QAAQ,8LAAU,KAAK,CAAC,gBAAgB;IAC9C,IAAI,OAAO,OACP,OAAO,qKAAI,SAAS,CAAC;IACzB,OAAO;AACX;AAmBO,SAAS,eAAe,OAAO;IAClC,OAAO,yKAAQ,aAAa,CAAC,iBAAiB;AAClD;AAmBO,SAAS,iBAAiB,OAAO;IACpC,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG;IAC/B,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,GAAG;IAC1B,MAAM,aAAa,IAAI,8LAAU,SAAS,CAAC,OAAO,IAAI,OAAO,IAAI,cAAc,CAAC;IAChF,MAAM,QAAQ,WAAW,gBAAgB,CAAC,qKAAI,IAAI,CAAC,SAAS,SAAS,CAAC;IACtE,OAAO,2KAAU,IAAI,CAAC;AAC1B;AAiBO,SAAS,KAAK,OAAO;IACxB,MAAM,EAAE,eAAe,qLAAQ,YAAY,EAAE,IAAI,EAAE,OAAO,EAAE,UAAU,EAAG,GAAG;IAC5E,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,EAAE,GAAG,8LAAU,IAAI,CAAC,uKAAM,IAAI,CAAC,UAAU,uKAAM,IAAI,CAAC,aAAa;QACnF,cAAc,OAAO,iBAAiB,YAChC,eACA,qKAAI,IAAI,CAAC,cAAc,KAAK,CAAC;QACnC,MAAM;QACN,GAAI,OAAO;YAAE,SAAS;QAAK,IAAI,CAAC,CAAC;IACrC;IACA,OAAO;QACH;QACA;QACA,SAAS;IACb;AACJ;AAuCO,SAAS,OAAO,OAAO;IAC1B,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG;IACzD,IAAI,SACA,OAAO,yKAAQ,OAAO,CAAC,SAAS,eAAe;QAAE;QAAS;IAAU;IACxE,OAAO,8LAAU,MAAM,CAAC,WAAW,uKAAM,IAAI,CAAC,UAAU,2KAAU,OAAO,CAAC,eAAgB,OAAO;QAAC;YAAE,SAAS;YAAM,MAAM;QAAK;KAAE,GAAG,EAAE;AACzI,EACA,qCAAqC"}},
    {"offset": {"line": 3001, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3006, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/internal/cursor.js"],"sourcesContent":["import * as Errors from '../Errors.js';\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\n/** @internal */\nexport function create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\n//# sourceMappingURL=cursor.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3213, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3218, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Rlp.js"],"sourcesContent":["import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Cursor from './internal/cursor.js';\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nexport function toBytes(value) {\n    return to(value, 'Bytes');\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value) {\n    return to(value, 'Hex');\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */\nexport function to(value, to) {\n    const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes');\n    const bytes = (() => {\n        if (typeof value === 'string') {\n            if (value.length > 3 && value.length % 2 !== 0)\n                throw new Hex.InvalidLengthError(value);\n            return Bytes.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = Cursor.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY,\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */\n/** @internal */\nexport function decodeRlpCursor(cursor, to = 'Hex') {\n    if (cursor.bytes.length === 0)\n        return (to === 'Hex' ? Hex.fromBytes(cursor.bytes) : cursor.bytes);\n    const prefix = cursor.readByte();\n    if (prefix < 0x80)\n        cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return (to === 'Hex' ? Hex.fromBytes(bytes) : bytes);\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */\nexport function readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80)\n        return 1;\n    if (prefix <= offset + 55)\n        return prefix - offset;\n    if (prefix === offset + 55 + 1)\n        return cursor.readUint8();\n    if (prefix === offset + 55 + 2)\n        return cursor.readUint16();\n    if (prefix === offset + 55 + 3)\n        return cursor.readUint24();\n    if (prefix === offset + 55 + 4)\n        return cursor.readUint32();\n    throw new Errors.BaseError('Invalid RLP prefix');\n}\n/** @internal */\nexport function readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while (cursor.position - position < length)\n        value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = Cursor.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === 'Hex')\n        return Hex.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromBytes(bytes, options = {}) {\n    const { as = 'Bytes' } = options;\n    return from(bytes, { as });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromHex(hex, options = {}) {\n    const { as = 'Hex' } = options;\n    return from(hex, { as });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes))\n        return getEncodableList(bytes.map((x) => getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (() => {\n        if (bodyLength <= 55)\n            return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            }\n            else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1)\n                    cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2)\n                    cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3)\n                    cursor.pushUint24(bodyLength);\n                else\n                    cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list) {\n                encode(cursor);\n            }\n        },\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === 'string' ? Bytes.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (() => {\n        if (bytes.length === 1 && bytes[0] < 0x80)\n            return 1;\n        if (bytes.length <= 55)\n            return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            }\n            else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            }\n            else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1)\n                    cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2)\n                    cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3)\n                    cursor.pushUint24(bytes.length);\n                else\n                    cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        },\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length < 2 ** 8)\n        return 1;\n    if (length < 2 ** 16)\n        return 2;\n    if (length < 2 ** 24)\n        return 3;\n    if (length < 2 ** 32)\n        return 4;\n    throw new Errors.BaseError('Length is too large.');\n}\n//# sourceMappingURL=Rlp.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3374, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3379, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/Authorization.js"],"sourcesContent":["import * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function from(authorization, options = {}) {\n    if (typeof authorization.chainId === 'string')\n        return fromRpc(authorization);\n    return { ...authorization, ...options.signature };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nexport function fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = Signature.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nexport function fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    let args = {\n        address,\n        chainId: chainId === '0x' ? 0 : Number(chainId),\n        nonce: nonce === '0x' ? 0n : BigInt(nonce),\n    };\n    if (yParity && r && s)\n        args = { ...args, ...Signature.fromTuple([yParity, r, s]) };\n    return from(args);\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nexport function fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)\n        list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization) {\n    return hash(authorization, { presign: true });\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nexport function hash(authorization, options = {}) {\n    const { presign } = options;\n    return Hash.keccak256(Hex.concat('0x05', Rlp.fromHex(toTuple(presign\n        ? {\n            address: authorization.address,\n            chainId: authorization.chainId,\n            nonce: authorization.nonce,\n        }\n        : authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nexport function toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: Hex.fromNumber(chainId),\n        nonce: Hex.fromNumber(nonce),\n        ...Signature.toRpc(signature),\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nexport function toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nexport function toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = Signature.extract(authorization);\n    return [\n        chainId ? Hex.fromNumber(chainId) : '0x',\n        address,\n        nonce ? Hex.fromNumber(nonce) : '0x',\n        ...(signature ? Signature.toTuple(signature) : []),\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nexport function toTupleList(list) {\n    if (!list || list.length === 0)\n        return [];\n    const tupleList = [];\n    for (const authorization of list)\n        tupleList.push(toTuple(authorization));\n    return tupleList;\n}\n//# sourceMappingURL=Authorization.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AA+CO,SAAS,KAAK,aAAa,EAAE,UAAU,CAAC,CAAC;IAC5C,IAAI,OAAO,cAAc,OAAO,KAAK,UACjC,OAAO,QAAQ;IACnB,OAAO;QAAE,GAAG,aAAa;QAAE,GAAG,QAAQ,SAAS;IAAC;AACpD;AAqBO,SAAS,QAAQ,aAAa;IACjC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG;IACpC,MAAM,YAAY,2KAAU,OAAO,CAAC;IACpC,OAAO;QACH;QACA,SAAS,OAAO;QAChB,OAAO,OAAO;QACd,GAAG,SAAS;IAChB;AACJ;AAqBO,SAAS,YAAY,iBAAiB;IACzC,OAAO,kBAAkB,GAAG,CAAC;AACjC;AA+CO,SAAS,UAAU,KAAK;IAC3B,MAAM,CAAC,SAAS,SAAS,OAAO,SAAS,GAAG,EAAE,GAAG;IACjD,IAAI,OAAO;QACP;QACA,SAAS,YAAY,OAAO,IAAI,OAAO;QACvC,OAAO,UAAU,OAAO,EAAE,GAAG,OAAO;IACxC;IACA,IAAI,WAAW,KAAK,GAChB,OAAO;QAAE,GAAG,IAAI;QAAE,GAAG,2KAAU,SAAS,CAAC;YAAC;YAAS;YAAG;SAAE,CAAC;IAAC;IAC9D,OAAO,KAAK;AAChB;AA2DO,SAAS,cAAc,SAAS;IACnC,MAAM,OAAO,EAAE;IACf,KAAK,MAAM,SAAS,UAChB,KAAK,IAAI,CAAC,UAAU;IACxB,OAAO;AACX;AA4BO,SAAS,eAAe,aAAa;IACxC,OAAO,KAAK,eAAe;QAAE,SAAS;IAAK;AAC/C;AAoBO,SAAS,KAAK,aAAa,EAAE,UAAU,CAAC,CAAC;IAC5C,MAAM,EAAE,OAAO,EAAE,GAAG;IACpB,OAAO,sKAAK,SAAS,CAAC,qKAAI,MAAM,CAAC,QAAQ,qKAAI,OAAO,CAAC,QAAQ,UACvD;QACE,SAAS,cAAc,OAAO;QAC9B,SAAS,cAAc,OAAO;QAC9B,OAAO,cAAc,KAAK;IAC9B,IACE;AACV;AAqBO,SAAS,MAAM,aAAa;IAC/B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,WAAW,GAAG;IAClD,OAAO;QACH;QACA,SAAS,qKAAI,UAAU,CAAC;QACxB,OAAO,qKAAI,UAAU,CAAC;QACtB,GAAG,2KAAU,KAAK,CAAC,UAAU;IACjC;AACJ;AAqBO,SAAS,UAAU,iBAAiB;IACvC,OAAO,kBAAkB,GAAG,CAAC;AACjC;AAyBO,SAAS,QAAQ,aAAa;IACjC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG;IACpC,MAAM,YAAY,2KAAU,OAAO,CAAC;IACpC,OAAO;QACH,UAAU,qKAAI,UAAU,CAAC,WAAW;QACpC;QACA,QAAQ,qKAAI,UAAU,CAAC,SAAS;WAC5B,YAAY,2KAAU,OAAO,CAAC,aAAa,EAAE;KACpD;AACL;AAqCO,SAAS,YAAY,IAAI;IAC5B,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GACzB,OAAO,EAAE;IACb,MAAM,YAAY,EAAE;IACpB,KAAK,MAAM,iBAAiB,KACxB,UAAU,IAAI,CAAC,QAAQ;IAC3B,OAAO;AACX,EACA,yCAAyC"}},
    {"offset": {"line": 3484, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3489, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/internal/abiParameters.js"],"sourcesContent":["import * as AbiParameters from '../AbiParameters.js';\nimport * as Address from '../Address.js';\nimport * as Bytes from '../Bytes.js';\nimport * as Errors from '../Errors.js';\nimport * as Hex from '../Hex.js';\nimport { integerRegex } from '../Solidity.js';\n/** @internal */\nexport function decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nexport function decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? Address.checksum(address) : address;\n    return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\n/** @internal */\nexport function decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\n/** @internal */\nexport function decodeBool(cursor) {\n    return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\n/** @internal */\nexport function decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = Bytes.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = Bytes.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [Hex.fromBytes(data), 32];\n    }\n    const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n    return [value, 32];\n}\n/** @internal */\nexport function decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256', 10);\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? Bytes.toBigInt(value, { signed })\n            : Bytes.toNumber(value, { signed }),\n        32,\n    ];\n}\n/** @internal */\nexport function decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\n/** @internal */\nexport function decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = Bytes.toString(Bytes.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\n/** @internal */\nexport function prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */\nexport function prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new AbiParameters.InvalidTypeError(parameter.type);\n}\n/** @internal */\nexport function encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += Hex.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += Hex.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return Hex.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nexport function encodeAddress(value, options) {\n    const { checksum = false } = options;\n    Address.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: Hex.padLeft(value.toLowerCase()),\n    };\n}\n/** @internal */\nexport function encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new AbiParameters.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new AbiParameters.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = Hex.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nexport function encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = Hex.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize, 10))\n        throw new AbiParameters.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize, 10),\n            value,\n        });\n    return { dynamic: false, encoded: Hex.padRight(value) };\n}\n/** @internal */\nexport function encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) };\n}\n/** @internal */\nexport function encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new Hex.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\n/** @internal */\nexport function encodeString(value) {\n    const hexValue = Hex.fromString(value);\n    const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })), ...parts),\n    };\n}\n/** @internal */\nexport function encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nexport function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n/** @internal */\nexport function hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOO,SAAS,gBAAgB,MAAM,EAAE,KAAK,EAAE,OAAO;IAClD,MAAM,EAAE,eAAe,EAAE,cAAc,EAAE,GAAG;IAC5C,MAAM,kBAAkB,mBAAmB,MAAM,IAAI;IACrD,IAAI,iBAAiB;QACjB,MAAM,CAAC,QAAQ,KAAK,GAAG;QACvB,OAAO,YAAY,QAAQ;YAAE,GAAG,KAAK;YAAE;QAAK,GAAG;YAAE;YAAiB;YAAQ;QAAe;IAC7F;IACA,IAAI,MAAM,IAAI,KAAK,SACf,OAAO,YAAY,QAAQ,OAAO;QAC9B;QACA;IACJ;IACJ,IAAI,MAAM,IAAI,KAAK,WACf,OAAO,cAAc,QAAQ;QAAE,UAAU;IAAgB;IAC7D,IAAI,MAAM,IAAI,KAAK,QACf,OAAO,WAAW;IACtB,IAAI,MAAM,IAAI,CAAC,UAAU,CAAC,UACtB,OAAO,YAAY,QAAQ,OAAO;QAAE;IAAe;IACvD,IAAI,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,MAAM,IAAI,CAAC,UAAU,CAAC,QACvD,OAAO,aAAa,QAAQ;IAChC,IAAI,MAAM,IAAI,KAAK,UACf,OAAO,aAAa,QAAQ;QAAE;IAAe;IACjD,MAAM,IAAI,+KAAc,gBAAgB,CAAC,MAAM,IAAI;AACvD;AACA,MAAM,eAAe;AACrB,MAAM,eAAe;AAEd,SAAS,cAAc,MAAM,EAAE,UAAU,CAAC,CAAC;IAC9C,MAAM,EAAE,WAAW,KAAK,EAAE,GAAG;IAC7B,MAAM,QAAQ,OAAO,SAAS,CAAC;IAC/B,MAAM,OAAO,CAAC,UAAY,WAAW,yKAAQ,QAAQ,CAAC,WAAW;IACjE,OAAO;QAAC,KAAK,qKAAI,SAAS,CAAC,uKAAM,KAAK,CAAC,OAAO,CAAC;QAAO;KAAG;AAC7D;AAEO,SAAS,YAAY,MAAM,EAAE,KAAK,EAAE,OAAO;IAC9C,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG;IACpD,sEAAsE;IACtE,mEAAmE;IACnE,IAAI,CAAC,QAAQ;QACT,oEAAoE;QACpE,MAAM,SAAS,uKAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,yDAAyD;QACzD,MAAM,QAAQ,iBAAiB;QAC/B,MAAM,cAAc,QAAQ;QAC5B,+CAA+C;QAC/C,OAAO,WAAW,CAAC;QACnB,MAAM,SAAS,uKAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,+CAA+C;QAC/C,MAAM,eAAe,gBAAgB;QACrC,IAAI,WAAW;QACf,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,EAAE,EAAG;YAC7B,iHAAiH;YACjH,2EAA2E;YAC3E,OAAO,WAAW,CAAC,cAAc,CAAC,eAAe,IAAI,KAAK,QAAQ;YAClE,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,QAAQ,OAAO;gBACrD;gBACA,gBAAgB;YACpB;YACA,YAAY;YACZ,MAAM,IAAI,CAAC;QACf;QACA,2EAA2E;QAC3E,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC;YAAO;SAAG;IACtB;IACA,kDAAkD;IAClD,wEAAwE;IACxE,kDAAkD;IAClD,IAAI,gBAAgB,QAAQ;QACxB,mEAAmE;QACnE,MAAM,SAAS,uKAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,yDAAyD;QACzD,MAAM,QAAQ,iBAAiB;QAC/B,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,EAAE,EAAG;YAC7B,4DAA4D;YAC5D,OAAO,WAAW,CAAC,QAAQ,IAAI;YAC/B,MAAM,CAAC,KAAK,GAAG,gBAAgB,QAAQ,OAAO;gBAC1C;gBACA,gBAAgB;YACpB;YACA,MAAM,IAAI,CAAC;QACf;QACA,2EAA2E;QAC3E,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC;YAAO;SAAG;IACtB;IACA,iFAAiF;IACjF,oDAAoD;IACpD,IAAI,WAAW;IACf,MAAM,QAAQ,EAAE;IAChB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,EAAE,EAAG;QAC7B,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,QAAQ,OAAO;YACrD;YACA,gBAAgB,iBAAiB;QACrC;QACA,YAAY;QACZ,MAAM,IAAI,CAAC;IACf;IACA,OAAO;QAAC;QAAO;KAAS;AAC5B;AAEO,SAAS,WAAW,MAAM;IAC7B,OAAO;QAAC,uKAAM,SAAS,CAAC,OAAO,SAAS,CAAC,KAAK;YAAE,MAAM;QAAG;QAAI;KAAG;AACpE;AAEO,SAAS,YAAY,MAAM,EAAE,KAAK,EAAE,EAAE,cAAc,EAAE;IACzD,MAAM,CAAC,GAAG,KAAK,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC;IACnC,IAAI,CAAC,MAAM;QACP,mEAAmE;QACnE,MAAM,SAAS,uKAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,qDAAqD;QACrD,OAAO,WAAW,CAAC,iBAAiB;QACpC,MAAM,SAAS,uKAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,4CAA4C;QAC5C,IAAI,WAAW,GAAG;YACd,2EAA2E;YAC3E,OAAO,WAAW,CAAC,iBAAiB;YACpC,OAAO;gBAAC;gBAAM;aAAG;QACrB;QACA,MAAM,OAAO,OAAO,SAAS,CAAC;QAC9B,2EAA2E;QAC3E,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC,qKAAI,SAAS,CAAC;YAAO;SAAG;IACpC;IACA,MAAM,QAAQ,qKAAI,SAAS,CAAC,OAAO,SAAS,CAAC,OAAO,QAAQ,CAAC,MAAM,KAAK;IACxE,OAAO;QAAC;QAAO;KAAG;AACtB;AAEO,SAAS,aAAa,MAAM,EAAE,KAAK;IACtC,MAAM,SAAS,MAAM,IAAI,CAAC,UAAU,CAAC;IACrC,MAAM,OAAO,OAAO,QAAQ,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,IAAI,OAAO;IAClE,MAAM,QAAQ,OAAO,SAAS,CAAC;IAC/B,OAAO;QACH,OAAO,KACD,uKAAM,QAAQ,CAAC,OAAO;YAAE;QAAO,KAC/B,uKAAM,QAAQ,CAAC,OAAO;YAAE;QAAO;QACrC;KACH;AACL;AAEO,SAAS,YAAY,MAAM,EAAE,KAAK,EAAE,OAAO;IAC9C,MAAM,EAAE,eAAe,EAAE,cAAc,EAAE,GAAG;IAC5C,wEAAwE;IACxE,0EAA0E;IAC1E,4EAA4E;IAC5E,0EAA0E;IAC1E,MAAM,kBAAkB,MAAM,UAAU,CAAC,MAAM,KAAK,KAAK,MAAM,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,GAAK,CAAC;IAC9F,0EAA0E;IAC1E,6BAA6B;IAC7B,MAAM,QAAQ,kBAAkB,EAAE,GAAG,CAAC;IACtC,IAAI,WAAW;IACf,2EAA2E;IAC3E,cAAc;IACd,IAAI,gBAAgB,QAAQ;QACxB,mEAAmE;QACnE,MAAM,SAAS,uKAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,6DAA6D;QAC7D,MAAM,QAAQ,iBAAiB;QAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,UAAU,CAAC,MAAM,EAAE,EAAE,EAAG;YAC9C,MAAM,YAAY,MAAM,UAAU,CAAC,EAAE;YACrC,OAAO,WAAW,CAAC,QAAQ;YAC3B,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,QAAQ,WAAW;gBACzD;gBACA,gBAAgB;YACpB;YACA,YAAY;YACZ,KAAK,CAAC,kBAAkB,IAAI,WAAW,KAAK,GAAG;QACnD;QACA,2EAA2E;QAC3E,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC;YAAO;SAAG;IACtB;IACA,sEAAsE;IACtE,eAAe;IACf,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,UAAU,CAAC,MAAM,EAAE,EAAE,EAAG;QAC9C,MAAM,YAAY,MAAM,UAAU,CAAC,EAAE;QACrC,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,QAAQ,WAAW;YACzD;YACA;QACJ;QACA,KAAK,CAAC,kBAAkB,IAAI,WAAW,KAAK,GAAG;QAC/C,YAAY;IAChB;IACA,OAAO;QAAC;QAAO;KAAS;AAC5B;AAEO,SAAS,aAAa,MAAM,EAAE,EAAE,cAAc,EAAE;IACnD,sCAAsC;IACtC,MAAM,SAAS,uKAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;IAC/C,yDAAyD;IACzD,MAAM,QAAQ,iBAAiB;IAC/B,OAAO,WAAW,CAAC;IACnB,MAAM,SAAS,uKAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;IAC/C,2DAA2D;IAC3D,IAAI,WAAW,GAAG;QACd,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC;YAAI;SAAG;IACnB;IACA,MAAM,OAAO,OAAO,SAAS,CAAC,QAAQ;IACtC,MAAM,QAAQ,uKAAM,QAAQ,CAAC,uKAAM,QAAQ,CAAC;IAC5C,2EAA2E;IAC3E,OAAO,WAAW,CAAC,iBAAiB;IACpC,OAAO;QAAC;QAAO;KAAG;AACtB;AAEO,SAAS,kBAAkB,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,EAAG;IACtE,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;QACxC,mBAAmB,IAAI,CAAC,iBAAiB;YACrC;YACA,WAAW,UAAU,CAAC,EAAE;YACxB,OAAO,MAAM,CAAC,EAAE;QACpB;IACJ;IACA,OAAO;AACX;AAEO,SAAS,iBAAiB,EAAE,kBAAkB,KAAK,EAAE,WAAW,UAAU,EAAE,KAAK,EAAG;IACvF,MAAM,YAAY;IAClB,MAAM,kBAAkB,mBAAmB,UAAU,IAAI;IACzD,IAAI,iBAAiB;QACjB,MAAM,CAAC,QAAQ,KAAK,GAAG;QACvB,OAAO,YAAY,OAAO;YACtB;YACA;YACA,WAAW;gBACP,GAAG,SAAS;gBACZ;YACJ;QACJ;IACJ;IACA,IAAI,UAAU,IAAI,KAAK,SAAS;QAC5B,OAAO,YAAY,OAAO;YACtB;YACA,WAAW;QACf;IACJ;IACA,IAAI,UAAU,IAAI,KAAK,WAAW;QAC9B,OAAO,cAAc,OAAO;YACxB,UAAU;QACd;IACJ;IACA,IAAI,UAAU,IAAI,KAAK,QAAQ;QAC3B,OAAO,cAAc;IACzB;IACA,IAAI,UAAU,IAAI,CAAC,UAAU,CAAC,WAAW,UAAU,IAAI,CAAC,UAAU,CAAC,QAAQ;QACvE,MAAM,SAAS,UAAU,IAAI,CAAC,UAAU,CAAC;QACzC,MAAM,KAAK,OAAO,KAAK,CAAC,GAAG,0LAAa,IAAI,CAAC,UAAU,IAAI,KAAK,EAAE;QAClE,OAAO,aAAa,OAAO;YACvB;YACA,MAAM,OAAO;QACjB;IACJ;IACA,IAAI,UAAU,IAAI,CAAC,UAAU,CAAC,UAAU;QACpC,OAAO,YAAY,OAAO;YAAE,MAAM,UAAU,IAAI;QAAC;IACrD;IACA,IAAI,UAAU,IAAI,KAAK,UAAU;QAC7B,OAAO,aAAa;IACxB;IACA,MAAM,IAAI,+KAAc,gBAAgB,CAAC,UAAU,IAAI;AAC3D;AAEO,SAAS,OAAO,kBAAkB;IACrC,4DAA4D;IAC5D,IAAI,aAAa;IACjB,IAAK,IAAI,IAAI,GAAG,IAAI,mBAAmB,MAAM,EAAE,IAAK;QAChD,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,kBAAkB,CAAC,EAAE;QAClD,IAAI,SACA,cAAc;aAEd,cAAc,qKAAI,IAAI,CAAC;IAC/B;IACA,yDAAyD;IACzD,MAAM,mBAAmB,EAAE;IAC3B,MAAM,oBAAoB,EAAE;IAC5B,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,mBAAmB,MAAM,EAAE,IAAK;QAChD,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,kBAAkB,CAAC,EAAE;QAClD,IAAI,SAAS;YACT,iBAAiB,IAAI,CAAC,qKAAI,UAAU,CAAC,aAAa,aAAa;gBAAE,MAAM;YAAG;YAC1E,kBAAkB,IAAI,CAAC;YACvB,eAAe,qKAAI,IAAI,CAAC;QAC5B,OACK;YACD,iBAAiB,IAAI,CAAC;QAC1B;IACJ;IACA,2CAA2C;IAC3C,OAAO,qKAAI,MAAM,IAAI,qBAAqB;AAC9C;AAEO,SAAS,cAAc,KAAK,EAAE,OAAO;IACxC,MAAM,EAAE,WAAW,KAAK,EAAE,GAAG;IAC7B,yKAAQ,MAAM,CAAC,OAAO;QAAE,QAAQ;IAAS;IACzC,OAAO;QACH,SAAS;QACT,SAAS,qKAAI,OAAO,CAAC,MAAM,WAAW;IAC1C;AACJ;AAEO,SAAS,YAAY,KAAK,EAAE,OAAO;IACtC,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG;IAC/C,MAAM,UAAU,WAAW;IAC3B,IAAI,CAAC,MAAM,OAAO,CAAC,QACf,MAAM,IAAI,+KAAc,iBAAiB,CAAC;IAC9C,IAAI,CAAC,WAAW,MAAM,MAAM,KAAK,QAC7B,MAAM,IAAI,+KAAc,wBAAwB,CAAC;QAC7C,gBAAgB;QAChB,aAAa,MAAM,MAAM;QACzB,MAAM,CAAC,EAAE,UAAU,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;IACxC;IACJ,IAAI,eAAe;IACnB,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACnC,MAAM,gBAAgB,iBAAiB;YACnC;YACA;YACA,OAAO,KAAK,CAAC,EAAE;QACnB;QACA,IAAI,cAAc,OAAO,EACrB,eAAe;QACnB,mBAAmB,IAAI,CAAC;IAC5B;IACA,IAAI,WAAW,cAAc;QACzB,MAAM,OAAO,OAAO;QACpB,IAAI,SAAS;YACT,MAAM,SAAS,qKAAI,UAAU,CAAC,mBAAmB,MAAM,EAAE;gBAAE,MAAM;YAAG;YACpE,OAAO;gBACH,SAAS;gBACT,SAAS,mBAAmB,MAAM,GAAG,IAAI,qKAAI,MAAM,CAAC,QAAQ,QAAQ;YACxE;QACJ;QACA,IAAI,cACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAAK;IAC9C;IACA,OAAO;QACH,SAAS;QACT,SAAS,qKAAI,MAAM,IAAI,mBAAmB,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,GAAK;IACnE;AACJ;AAEO,SAAS,YAAY,KAAK,EAAE,EAAE,IAAI,EAAE;IACvC,MAAM,GAAG,cAAc,GAAG,KAAK,KAAK,CAAC;IACrC,MAAM,YAAY,qKAAI,IAAI,CAAC;IAC3B,IAAI,CAAC,eAAe;QAChB,IAAI,SAAS;QACb,wDAAwD;QACxD,4CAA4C;QAC5C,IAAI,YAAY,OAAO,GACnB,SAAS,qKAAI,QAAQ,CAAC,QAAQ,KAAK,IAAI,CAAC,CAAC,MAAM,MAAM,GAAG,CAAC,IAAI,IAAI,MAAM;QAC3E,OAAO;YACH,SAAS;YACT,SAAS,qKAAI,MAAM,CAAC,qKAAI,OAAO,CAAC,qKAAI,UAAU,CAAC,WAAW;gBAAE,MAAM;YAAG,KAAK;QAC9E;IACJ;IACA,IAAI,cAAc,OAAO,QAAQ,CAAC,eAAe,KAC7C,MAAM,IAAI,+KAAc,sBAAsB,CAAC;QAC3C,cAAc,OAAO,QAAQ,CAAC,eAAe;QAC7C;IACJ;IACJ,OAAO;QAAE,SAAS;QAAO,SAAS,qKAAI,QAAQ,CAAC;IAAO;AAC1D;AAEO,SAAS,cAAc,KAAK;IAC/B,IAAI,OAAO,UAAU,WACjB,MAAM,IAAI,wKAAO,SAAS,CAAC,CAAC,wBAAwB,EAAE,MAAM,SAAS,EAAE,OAAO,MAAM,mCAAmC,CAAC;IAC5H,OAAO;QAAE,SAAS;QAAO,SAAS,qKAAI,OAAO,CAAC,qKAAI,WAAW,CAAC;IAAQ;AAC1E;AAEO,SAAS,aAAa,KAAK,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE;IAChD,IAAI,OAAO,SAAS,UAAU;QAC1B,MAAM,MAAM,EAAE,IAAI,CAAC,OAAO,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE;QAC1D,MAAM,MAAM,SAAS,CAAC,MAAM,EAAE,GAAG,EAAE;QACnC,IAAI,QAAQ,OAAO,QAAQ,KACvB,MAAM,IAAI,qKAAI,sBAAsB,CAAC;YACjC,KAAK,IAAI,QAAQ;YACjB,KAAK,IAAI,QAAQ;YACjB;YACA,MAAM,OAAO;YACb,OAAO,MAAM,QAAQ;QACzB;IACR;IACA,OAAO;QACH,SAAS;QACT,SAAS,qKAAI,UAAU,CAAC,OAAO;YAC3B,MAAM;YACN;QACJ;IACJ;AACJ;AAEO,SAAS,aAAa,KAAK;IAC9B,MAAM,WAAW,qKAAI,UAAU,CAAC;IAChC,MAAM,cAAc,KAAK,IAAI,CAAC,qKAAI,IAAI,CAAC,YAAY;IACnD,MAAM,QAAQ,EAAE;IAChB,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,IAAK;QAClC,MAAM,IAAI,CAAC,qKAAI,QAAQ,CAAC,qKAAI,KAAK,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI;IAClE;IACA,OAAO;QACH,SAAS;QACT,SAAS,qKAAI,MAAM,CAAC,qKAAI,QAAQ,CAAC,qKAAI,UAAU,CAAC,qKAAI,IAAI,CAAC,WAAW;YAAE,MAAM;QAAG,QAAQ;IAC3F;AACJ;AAEO,SAAS,YAAY,KAAK,EAAE,OAAO;IACtC,MAAM,EAAE,eAAe,EAAE,SAAS,EAAE,GAAG;IACvC,IAAI,UAAU;IACd,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,UAAU,CAAC,MAAM,EAAE,IAAK;QAClD,MAAM,SAAS,UAAU,UAAU,CAAC,EAAE;QACtC,MAAM,QAAQ,MAAM,OAAO,CAAC,SAAS,IAAI,OAAO,IAAI;QACpD,MAAM,gBAAgB,iBAAiB;YACnC;YACA,WAAW;YACX,OAAO,KAAK,CAAC,MAAM;QACvB;QACA,mBAAmB,IAAI,CAAC;QACxB,IAAI,cAAc,OAAO,EACrB,UAAU;IAClB;IACA,OAAO;QACH;QACA,SAAS,UACH,OAAO,sBACP,qKAAI,MAAM,IAAI,mBAAmB,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,GAAK;IAChE;AACJ;AAEO,SAAS,mBAAmB,IAAI;IACnC,MAAM,UAAU,KAAK,KAAK,CAAC;IAC3B,OAAO,UAEC;QAAC,OAAO,CAAC,EAAE,GAAG,OAAO,OAAO,CAAC,EAAE,IAAI;QAAM,OAAO,CAAC,EAAE;KAAC,GACtD;AACV;AAEO,SAAS,gBAAgB,KAAK;IACjC,MAAM,EAAE,IAAI,EAAE,GAAG;IACjB,IAAI,SAAS,UACT,OAAO;IACX,IAAI,SAAS,SACT,OAAO;IACX,IAAI,KAAK,QAAQ,CAAC,OACd,OAAO;IACX,IAAI,SAAS,SACT,OAAO,MAAM,UAAU,EAAE,KAAK;IAClC,MAAM,kBAAkB,mBAAmB,MAAM,IAAI;IACrD,IAAI,mBACA,gBAAgB;QACZ,GAAG,KAAK;QACR,MAAM,eAAe,CAAC,EAAE;IAC5B,IACA,OAAO;IACX,OAAO;AACX,EACA,yCAAyC"}},
    {"offset": {"line": 4010, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4015, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/AbiParameters.js"],"sourcesContent":["import * as abitype from 'abitype';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/abiParameters.js';\nimport * as Cursor from './internal/cursor.js';\nimport * as Solidity from './Solidity.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data;\n    const cursor = Cursor.create(bytes);\n    if (Bytes.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (Bytes.size(bytes) && Bytes.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : Hex.fromBytes(data),\n            parameters: parameters,\n            size: Bytes.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = internal.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nexport function encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = internal.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = internal.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nexport function encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return Hex.concat(...data);\n}\n(function (encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            Address.assert(address);\n            return Hex.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return Hex.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return Hex.padLeft(Hex.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(Solidity.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits, 10) / 8;\n            return Hex.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(Solidity.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size, 10) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size, 10),\n                    value: value,\n                });\n            return Hex.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(Solidity.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return Hex.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nexport function format(parameters) {\n    return abitype.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nexport function from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                               2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nexport class DataSizeTooSmallError extends Errors.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                             zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nexport class ZeroDataError extends Errors.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                                expected: 3    length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                           length: 3\n * ```\n */\nexport class ArrayLengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                             expected: 8 bytes    size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                         size: 8 bytes\n * ```\n */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${Hex.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nexport class LengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nexport class InvalidArrayError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                               invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nexport class InvalidTypeError extends Errors.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiParameters.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4237, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4242, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/erc8010/SignatureErc8010.js"],"sourcesContent":["import * as AbiParameters from '../core/AbiParameters.js';\nimport * as Authorization from '../core/Authorization.js';\nimport * as Errors from '../core/Errors.js';\nimport * as Hex from '../core/Hex.js';\nimport * as Secp256k1 from '../core/Secp256k1.js';\nimport * as Signature from '../core/Signature.js';\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */\nexport const magicBytes = '0x8010801080108010801080108010801080108010801080108010801080108010';\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */\nexport const suffixParameters = AbiParameters.from('(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data');\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */\nexport function assert(value) {\n    if (typeof value === 'string') {\n        if (Hex.slice(value, -32) !== magicBytes)\n            throw new InvalidWrappedSignatureError(value);\n    }\n    else\n        Signature.assert(value.authorization);\n}\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */\nexport function from(value) {\n    if (typeof value === 'string')\n        return unwrap(value);\n    return value;\n}\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */\nexport function unwrap(wrapped) {\n    assert(wrapped);\n    const suffixLength = Hex.toNumber(Hex.slice(wrapped, -64, -32));\n    const suffix = Hex.slice(wrapped, -suffixLength - 64, -64);\n    const signature = Hex.slice(wrapped, 0, -suffixLength - 64);\n    const [auth, to, data] = AbiParameters.decode(suffixParameters, suffix);\n    const authorization = Authorization.from({\n        address: auth.delegation,\n        chainId: Number(auth.chainId),\n        nonce: auth.nonce,\n        yParity: auth.yParity,\n        r: auth.r,\n        s: auth.s,\n    });\n    return {\n        authorization,\n        signature,\n        ...(data && data !== '0x' ? { data, to } : {}),\n    };\n}\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */\nexport function wrap(value) {\n    const { data, signature } = value;\n    assert(value);\n    const self = Secp256k1.recoverAddress({\n        payload: Authorization.getSignPayload(value.authorization),\n        signature: Signature.from(value.authorization),\n    });\n    const suffix = AbiParameters.encode(suffixParameters, [\n        {\n            ...value.authorization,\n            delegation: value.authorization.address,\n            chainId: BigInt(value.authorization.chainId),\n        },\n        value.to ?? self,\n        data ?? '0x',\n    ]);\n    const suffixLength = Hex.fromNumber(Hex.size(suffix), { size: 32 });\n    return Hex.concat(signature, suffix, suffixLength, magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */\nexport function validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-8010 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc8010.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc8010.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AASO,MAAM,aAAa;AAEnB,MAAM,mBAAmB,+KAAc,IAAI,CAAC;AAc5C,SAAS,OAAO,KAAK;IACxB,IAAI,OAAO,UAAU,UAAU;QAC3B,IAAI,qKAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,YAC1B,MAAM,IAAI,6BAA6B;IAC/C,OAEI,2KAAU,MAAM,CAAC,MAAM,aAAa;AAC5C;AA+BO,SAAS,KAAK,KAAK;IACtB,IAAI,OAAO,UAAU,UACjB,OAAO,OAAO;IAClB,OAAO;AACX;AAcO,SAAS,OAAO,OAAO;IAC1B,OAAO;IACP,MAAM,eAAe,qKAAI,QAAQ,CAAC,qKAAI,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC;IAC3D,MAAM,SAAS,qKAAI,KAAK,CAAC,SAAS,CAAC,eAAe,IAAI,CAAC;IACvD,MAAM,YAAY,qKAAI,KAAK,CAAC,SAAS,GAAG,CAAC,eAAe;IACxD,MAAM,CAAC,MAAM,IAAI,KAAK,GAAG,+KAAc,MAAM,CAAC,kBAAkB;IAChE,MAAM,gBAAgB,+KAAc,IAAI,CAAC;QACrC,SAAS,KAAK,UAAU;QACxB,SAAS,OAAO,KAAK,OAAO;QAC5B,OAAO,KAAK,KAAK;QACjB,SAAS,KAAK,OAAO;QACrB,GAAG,KAAK,CAAC;QACT,GAAG,KAAK,CAAC;IACb;IACA,OAAO;QACH;QACA;QACA,GAAI,QAAQ,SAAS,OAAO;YAAE;YAAM;QAAG,IAAI,CAAC,CAAC;IACjD;AACJ;AAyBO,SAAS,KAAK,KAAK;IACtB,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,GAAG;IAC5B,OAAO;IACP,MAAM,OAAO,2KAAU,cAAc,CAAC;QAClC,SAAS,+KAAc,cAAc,CAAC,MAAM,aAAa;QACzD,WAAW,2KAAU,IAAI,CAAC,MAAM,aAAa;IACjD;IACA,MAAM,SAAS,+KAAc,MAAM,CAAC,kBAAkB;QAClD;YACI,GAAG,MAAM,aAAa;YACtB,YAAY,MAAM,aAAa,CAAC,OAAO;YACvC,SAAS,OAAO,MAAM,aAAa,CAAC,OAAO;QAC/C;QACA,MAAM,EAAE,IAAI;QACZ,QAAQ;KACX;IACD,MAAM,eAAe,qKAAI,UAAU,CAAC,qKAAI,IAAI,CAAC,SAAS;QAAE,MAAM;IAAG;IACjE,OAAO,qKAAI,MAAM,CAAC,WAAW,QAAQ,cAAc;AACvD;AAeO,SAAS,SAAS,KAAK;IAC1B,IAAI;QACA,OAAO;QACP,OAAO;IACX,EACA,OAAM;QACF,OAAO;IACX;AACJ;AAEO,MAAM,qCAAqC,wKAAO,SAAS;IAC9D,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,CAAC,QAAQ,EAAE,QAAQ,4CAA4C,CAAC;QACtE,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,4CAA4C"}},
    {"offset": {"line": 4339, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4354, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/erc6492/index.js"],"sourcesContent":["/**\n * Utility functions for working with [ERC-6492 wrapped signatures](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, PersonalMessage } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: PersonalMessage.getSignPayload('0xdeadbeef'),\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = WrappedSignature.toHex({ // [!code focus]\n *   data: '0xcafebabe', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0xcafebabecafebabecafebabecafebabecafebabe', // [!code focus]\n * }) // [!code focus]\n * // @log: '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041fa78c5905fb0b9d6066ef531f962a62bc6ef0d5eb59ecb134056d206f75aaed7780926ff2601a935c2c79707d9e1799948c9f19dcdde1e090e903b19a07923d01c000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n * ```\n *\n * @category ERC-6492\n */\nexport * as WrappedSignature from './WrappedSignature.js';\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;CAsBC;;CAED,iCAAiC"}},
    {"offset": {"line": 4379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4384, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Solidity.js"],"sourcesContent":["export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const maxInt8 = 2n ** (8n - 1n) - 1n;\nexport const maxInt16 = 2n ** (16n - 1n) - 1n;\nexport const maxInt24 = 2n ** (24n - 1n) - 1n;\nexport const maxInt32 = 2n ** (32n - 1n) - 1n;\nexport const maxInt40 = 2n ** (40n - 1n) - 1n;\nexport const maxInt48 = 2n ** (48n - 1n) - 1n;\nexport const maxInt56 = 2n ** (56n - 1n) - 1n;\nexport const maxInt64 = 2n ** (64n - 1n) - 1n;\nexport const maxInt72 = 2n ** (72n - 1n) - 1n;\nexport const maxInt80 = 2n ** (80n - 1n) - 1n;\nexport const maxInt88 = 2n ** (88n - 1n) - 1n;\nexport const maxInt96 = 2n ** (96n - 1n) - 1n;\nexport const maxInt104 = 2n ** (104n - 1n) - 1n;\nexport const maxInt112 = 2n ** (112n - 1n) - 1n;\nexport const maxInt120 = 2n ** (120n - 1n) - 1n;\nexport const maxInt128 = 2n ** (128n - 1n) - 1n;\nexport const maxInt136 = 2n ** (136n - 1n) - 1n;\nexport const maxInt144 = 2n ** (144n - 1n) - 1n;\nexport const maxInt152 = 2n ** (152n - 1n) - 1n;\nexport const maxInt160 = 2n ** (160n - 1n) - 1n;\nexport const maxInt168 = 2n ** (168n - 1n) - 1n;\nexport const maxInt176 = 2n ** (176n - 1n) - 1n;\nexport const maxInt184 = 2n ** (184n - 1n) - 1n;\nexport const maxInt192 = 2n ** (192n - 1n) - 1n;\nexport const maxInt200 = 2n ** (200n - 1n) - 1n;\nexport const maxInt208 = 2n ** (208n - 1n) - 1n;\nexport const maxInt216 = 2n ** (216n - 1n) - 1n;\nexport const maxInt224 = 2n ** (224n - 1n) - 1n;\nexport const maxInt232 = 2n ** (232n - 1n) - 1n;\nexport const maxInt240 = 2n ** (240n - 1n) - 1n;\nexport const maxInt248 = 2n ** (248n - 1n) - 1n;\nexport const maxInt256 = 2n ** (256n - 1n) - 1n;\nexport const minInt8 = -(2n ** (8n - 1n));\nexport const minInt16 = -(2n ** (16n - 1n));\nexport const minInt24 = -(2n ** (24n - 1n));\nexport const minInt32 = -(2n ** (32n - 1n));\nexport const minInt40 = -(2n ** (40n - 1n));\nexport const minInt48 = -(2n ** (48n - 1n));\nexport const minInt56 = -(2n ** (56n - 1n));\nexport const minInt64 = -(2n ** (64n - 1n));\nexport const minInt72 = -(2n ** (72n - 1n));\nexport const minInt80 = -(2n ** (80n - 1n));\nexport const minInt88 = -(2n ** (88n - 1n));\nexport const minInt96 = -(2n ** (96n - 1n));\nexport const minInt104 = -(2n ** (104n - 1n));\nexport const minInt112 = -(2n ** (112n - 1n));\nexport const minInt120 = -(2n ** (120n - 1n));\nexport const minInt128 = -(2n ** (128n - 1n));\nexport const minInt136 = -(2n ** (136n - 1n));\nexport const minInt144 = -(2n ** (144n - 1n));\nexport const minInt152 = -(2n ** (152n - 1n));\nexport const minInt160 = -(2n ** (160n - 1n));\nexport const minInt168 = -(2n ** (168n - 1n));\nexport const minInt176 = -(2n ** (176n - 1n));\nexport const minInt184 = -(2n ** (184n - 1n));\nexport const minInt192 = -(2n ** (192n - 1n));\nexport const minInt200 = -(2n ** (200n - 1n));\nexport const minInt208 = -(2n ** (208n - 1n));\nexport const minInt216 = -(2n ** (216n - 1n));\nexport const minInt224 = -(2n ** (224n - 1n));\nexport const minInt232 = -(2n ** (232n - 1n));\nexport const minInt240 = -(2n ** (240n - 1n));\nexport const minInt248 = -(2n ** (248n - 1n));\nexport const minInt256 = -(2n ** (256n - 1n));\nexport const maxUint8 = 2n ** 8n - 1n;\nexport const maxUint16 = 2n ** 16n - 1n;\nexport const maxUint24 = 2n ** 24n - 1n;\nexport const maxUint32 = 2n ** 32n - 1n;\nexport const maxUint40 = 2n ** 40n - 1n;\nexport const maxUint48 = 2n ** 48n - 1n;\nexport const maxUint56 = 2n ** 56n - 1n;\nexport const maxUint64 = 2n ** 64n - 1n;\nexport const maxUint72 = 2n ** 72n - 1n;\nexport const maxUint80 = 2n ** 80n - 1n;\nexport const maxUint88 = 2n ** 88n - 1n;\nexport const maxUint96 = 2n ** 96n - 1n;\nexport const maxUint104 = 2n ** 104n - 1n;\nexport const maxUint112 = 2n ** 112n - 1n;\nexport const maxUint120 = 2n ** 120n - 1n;\nexport const maxUint128 = 2n ** 128n - 1n;\nexport const maxUint136 = 2n ** 136n - 1n;\nexport const maxUint144 = 2n ** 144n - 1n;\nexport const maxUint152 = 2n ** 152n - 1n;\nexport const maxUint160 = 2n ** 160n - 1n;\nexport const maxUint168 = 2n ** 168n - 1n;\nexport const maxUint176 = 2n ** 176n - 1n;\nexport const maxUint184 = 2n ** 184n - 1n;\nexport const maxUint192 = 2n ** 192n - 1n;\nexport const maxUint200 = 2n ** 200n - 1n;\nexport const maxUint208 = 2n ** 208n - 1n;\nexport const maxUint216 = 2n ** 216n - 1n;\nexport const maxUint224 = 2n ** 224n - 1n;\nexport const maxUint232 = 2n ** 232n - 1n;\nexport const maxUint240 = 2n ** 240n - 1n;\nexport const maxUint248 = 2n ** 248n - 1n;\nexport const maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map"],"names":[],"mappings":"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AI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACnC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,WAAW,EAAE,IAAI,EAAE,GAAG,EAAE;AAC9B,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,YAAY,EAAE,IAAI,GAAG,GAAG,EAAE;AAChC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE;AAClC,MAAM,aAAa,EAAE,IAAI,IAAI,GAAG,EAAE,EACzC,oCAAoC"}},
    {"offset": {"line": 4584, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4589, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Signature.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\nimport * as Solidity from './Solidity.js';\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (typeof signature.s === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (recovered && typeof signature.yParity === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (signature.r < 0n || signature.r > Solidity.maxUint256)\n        throw new InvalidRError({ value: signature.r });\n    if (signature.s < 0n || signature.s > Solidity.maxUint256)\n        throw new InvalidSError({ value: signature.s });\n    if (typeof signature.yParity === 'number' &&\n        signature.yParity !== 0 &&\n        signature.yParity !== 1)\n        throw new InvalidYParityError({ value: signature.yParity });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature) {\n    return fromHex(Hex.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132)\n        throw new InvalidSerializedSizeError({ signature });\n    const r = BigInt(Hex.slice(signature, 0, 32));\n    const s = BigInt(Hex.slice(signature, 32, 64));\n    const yParity = (() => {\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity))\n            return undefined;\n        try {\n            return vToYParity(yParity);\n        }\n        catch {\n            throw new InvalidYParityError({ value: yParity });\n        }\n    })();\n    if (typeof yParity === 'undefined')\n        return {\n            r,\n            s,\n        };\n    return {\n        r,\n        s,\n        yParity,\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value) {\n    if (typeof value.r === 'undefined')\n        return undefined;\n    if (typeof value.s === 'undefined')\n        return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from(signature) {\n    const signature_ = (() => {\n        if (typeof signature === 'string')\n            return fromHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature);\n        if (typeof signature.r === 'string')\n            return fromRpc(signature);\n        if (signature.v)\n            return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...(typeof signature.yParity !== 'undefined'\n                ? { yParity: signature.yParity }\n                : {}),\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature) {\n    return fromDerHex(Hex.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature) {\n    const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2));\n    return { r, s };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature) {\n    const yParity = (() => {\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === 'number' && typeof yParity !== 'number')\n            yParity = vToYParity(v);\n        if (typeof yParity !== 'number')\n            throw new InvalidYParityError({ value: signature.yParity });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity,\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === '0x' ? 0n : BigInt(r),\n        s: s === '0x' ? 0n : BigInt(s),\n        yParity: yParity === '0x' ? 0 : Number(yParity),\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature) {\n    return Bytes.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = Hex.concat(Hex.fromNumber(r, { size: 32 }), Hex.fromNumber(s, { size: 32 }), \n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n        ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n        : '0x');\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature) {\n    const sig = new secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature) {\n    const sig = new secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: Hex.fromNumber(r, { size: 32 }),\n        s: Hex.fromNumber(s, { size: 32 }),\n        yParity: yParity === 0 ? '0x0' : '0x1',\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? '0x01' : '0x',\n        r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r)),\n        s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s)),\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v) {\n    if (v === 0 || v === 27)\n        return 0;\n    if (v === 1 || v === 28)\n        return 1;\n    if (v >= 35)\n        return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({ value: v });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity) {\n    if (yParity === 0)\n        return 27;\n    if (yParity === 1)\n        return 28;\n    throw new InvalidYParityError({ value: yParity });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n    constructor({ signature }) {\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                'Expected: 64 bytes or 65 bytes.',\n                `Received ${Hex.size(Hex.from(signature))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSerializedSizeError'\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n    constructor({ signature }) {\n        super(`Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.MissingPropertiesError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidRError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidYParityError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidVError'\n        });\n    }\n}\n//# sourceMappingURL=Signature.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4890, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4895, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/internal/cursor.js"],"sourcesContent":["import * as Errors from '../Errors.js';\nconst staticCursor = /*#__PURE__*/ {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\n/** @internal */\nexport function create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\n//# sourceMappingURL=cursor.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5102, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5107, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/PublicKey.js"],"sourcesContent":["import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false ||\n        (typeof x === 'bigint' && typeof y === 'bigint')) {\n        if (prefix !== 4)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidUncompressedPrefixError(),\n            });\n        return;\n    }\n    // Compressed\n    if (compressed === true ||\n        (typeof x === 'bigint' && typeof y === 'undefined')) {\n        if (prefix !== 3 && prefix !== 2)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidCompressedPrefixError(),\n            });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({ publicKey });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport function compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x,\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nexport function from(value) {\n    const publicKey = (() => {\n        if (Hex.validate(value))\n            return fromHex(value);\n        if (Bytes.validate(value))\n            return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === 'bigint' && typeof y === 'bigint')\n            return { prefix: prefix ?? 0x04, x, y };\n        return { prefix, x };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromBytes(publicKey) {\n    return fromHex(Hex.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromHex(publicKey) {\n    if (publicKey.length !== 132 &&\n        publicKey.length !== 130 &&\n        publicKey.length !== 68)\n        throw new InvalidSerializedSizeError({ publicKey });\n    if (publicKey.length === 130) {\n        const x = BigInt(Hex.slice(publicKey, 0, 32));\n        const y = BigInt(Hex.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y,\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(Hex.slice(publicKey, 0, 1));\n        const x = BigInt(Hex.slice(publicKey, 1, 33));\n        const y = BigInt(Hex.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y,\n        };\n    }\n    const prefix = Number(Hex.slice(publicKey, 0, 1));\n    const x = BigInt(Hex.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x,\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toBytes(publicKey, options = {}) {\n    return Bytes.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = Hex.concat(includePrefix ? Hex.fromNumber(prefix, { size: 1 }) : '0x', Hex.fromNumber(x, { size: 32 }), \n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? Hex.fromNumber(y, { size: 32 }) : '0x');\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nexport class InvalidError extends Errors.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                'Public key must contain:',\n                '- an `x` and `prefix` value (compressed)',\n                '- an `x`, `y`, and `prefix` value (uncompressed)',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidError'\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */\nexport class InvalidPrefixError extends Errors.BaseError {\n    constructor({ prefix, cause }) {\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nexport class InvalidCompressedPrefixError extends Errors.BaseError {\n    constructor() {\n        super('Prefix must be 2 or 3 for compressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidCompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nexport class InvalidUncompressedPrefixError extends Errors.BaseError {\n    constructor() {\n        super('Prefix must be 4 for uncompressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidUncompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n                `Received ${Hex.size(Hex.from(publicKey))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidSerializedSizeError'\n        });\n    }\n}\n//# sourceMappingURL=PublicKey.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5306, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5311, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Hash.js"],"sourcesContent":["import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160';\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3';\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_keccak256(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_ripemd160(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_sha256(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value) {\n    return Hex.validate(value) && Hex.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AA0CO,SAAS,UAAU,KAAK,EAAE,UAAU,CAAC,CAAC;IACzC,MAAM,EAAE,KAAK,OAAO,UAAU,WAAW,QAAQ,OAAO,EAAE,GAAG;IAC7D,MAAM,QAAQ,wLAAgB,+IAAM,IAAI,CAAC;IACzC,IAAI,OAAO,SACP,OAAO;IACX,OAAO,6IAAI,SAAS,CAAC;AACzB;AAkBO,SAAS,UAAU,KAAK,EAAE,UAAU,CAAC,CAAC;IACzC,MAAM,EAAE,KAAK,OAAO,UAAU,WAAW,QAAQ,OAAO,EAAE,GAAG;IAC7D,MAAM,QAAQ,4LAAgB,+IAAM,IAAI,CAAC;IACzC,IAAI,OAAO,SACP,OAAO;IACX,OAAO,6IAAI,SAAS,CAAC;AACzB;AAkBO,SAAS,OAAO,KAAK,EAAE,UAAU,CAAC,CAAC;IACtC,MAAM,EAAE,KAAK,OAAO,UAAU,WAAW,QAAQ,OAAO,EAAE,GAAG;IAC7D,MAAM,QAAQ,sLAAa,+IAAM,IAAI,CAAC;IACtC,IAAI,OAAO,SACP,OAAO;IACX,OAAO,6IAAI,SAAS,CAAC;AACzB;AAkBO,SAAS,SAAS,KAAK;IAC1B,OAAO,6IAAI,QAAQ,CAAC,UAAU,6IAAI,IAAI,CAAC,WAAW;AACtD,EACA,gCAAgC"}},
    {"offset": {"line": 5349, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5354, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/internal/lru.js"],"sourcesContent":["/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map"],"names":[],"mappings":"AAAA;;;;;CAKC;;;AACM,MAAM,eAAe;IACxB,YAAY,IAAI,CAAE;QACd,KAAK;QACL,OAAO,cAAc,CAAC,IAAI,EAAE,WAAW;YACnC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,IAAI,GAAG,EAAE;QACL,MAAM,QAAQ,KAAK,CAAC,IAAI;QACxB,IAAI,KAAK,CAAC,IAAI,QAAQ,UAAU,WAAW;YACvC,IAAI,CAAC,MAAM,CAAC;YACZ,KAAK,CAAC,IAAI,KAAK;QACnB;QACA,OAAO;IACX;IACA,IAAI,GAAG,EAAE,KAAK,EAAE;QACZ,KAAK,CAAC,IAAI,KAAK;QACf,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE;YAC1C,MAAM,WAAW,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG,KAAK;YACzC,IAAI,UACA,IAAI,CAAC,MAAM,CAAC;QACpB;QACA,OAAO,IAAI;IACf;AACJ,EACA,+BAA+B"}},
    {"offset": {"line": 5390, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5395, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Caches.js"],"sourcesContent":["import { LruMap } from './internal/lru.js';\nconst caches = {\n    checksum: /*#__PURE__*/ new LruMap(8192),\n};\nexport const checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nexport function clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map"],"names":[],"mappings":";;;;;;;AACA,MAAM,SAAS;IACX,UAAU,WAAW,GAAG,uKAAW;AACvC;AACO,MAAM,WAAW,OAAO,QAAQ;AAUhC,SAAS;IACZ,KAAK,MAAM,SAAS,OAAO,MAAM,CAAC,QAC9B,MAAM,KAAK;AACnB,EACA,kCAAkC"}},
    {"offset": {"line": 5409, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5414, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/Address.js"],"sourcesContent":["import * as Bytes from './Bytes.js';\nimport * as Caches from './Caches.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as PublicKey from './PublicKey.js';\nconst addressRegex = /*#__PURE__*/ /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address) {\n    if (Caches.checksum.has(address))\n        return Caches.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    Caches.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(publicKey, options = {}) {\n    const address = Hash.keccak256(`0x${PublicKey.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError extends Errors.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\n//# sourceMappingURL=Address.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5538, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5543, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/internal/abiParameters.js"],"sourcesContent":["import * as AbiParameters from '../AbiParameters.js';\nimport * as Address from '../Address.js';\nimport * as Bytes from '../Bytes.js';\nimport * as Errors from '../Errors.js';\nimport * as Hex from '../Hex.js';\nimport { integerRegex } from '../Solidity.js';\n/** @internal */\nexport function decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nexport function decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? Address.checksum(address) : address;\n    return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\n/** @internal */\nexport function decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\n/** @internal */\nexport function decodeBool(cursor) {\n    return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\n/** @internal */\nexport function decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = Bytes.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = Bytes.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [Hex.fromBytes(data), 32];\n    }\n    const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32));\n    return [value, 32];\n}\n/** @internal */\nexport function decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256');\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? Bytes.toBigInt(value, { signed })\n            : Bytes.toNumber(value, { signed }),\n        32,\n    ];\n}\n/** @internal */\nexport function decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\n/** @internal */\nexport function decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = Bytes.toString(Bytes.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\n/** @internal */\nexport function prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */\nexport function prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new AbiParameters.InvalidTypeError(parameter.type);\n}\n/** @internal */\nexport function encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += Hex.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += Hex.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return Hex.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nexport function encodeAddress(value, options) {\n    const { checksum = false } = options;\n    Address.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: Hex.padLeft(value.toLowerCase()),\n    };\n}\n/** @internal */\nexport function encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new AbiParameters.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new AbiParameters.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = Hex.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nexport function encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = Hex.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize))\n        throw new AbiParameters.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize),\n            value,\n        });\n    return { dynamic: false, encoded: Hex.padRight(value) };\n}\n/** @internal */\nexport function encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) };\n}\n/** @internal */\nexport function encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new Hex.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\n/** @internal */\nexport function encodeString(value) {\n    const hexValue = Hex.fromString(value);\n    const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })), ...parts),\n    };\n}\n/** @internal */\nexport function encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nexport function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n/** @internal */\nexport function hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOO,SAAS,gBAAgB,MAAM,EAAE,KAAK,EAAE,OAAO;IAClD,MAAM,EAAE,eAAe,EAAE,cAAc,EAAE,GAAG;IAC5C,MAAM,kBAAkB,mBAAmB,MAAM,IAAI;IACrD,IAAI,iBAAiB;QACjB,MAAM,CAAC,QAAQ,KAAK,GAAG;QACvB,OAAO,YAAY,QAAQ;YAAE,GAAG,KAAK;YAAE;QAAK,GAAG;YAAE;YAAiB;YAAQ;QAAe;IAC7F;IACA,IAAI,MAAM,IAAI,KAAK,SACf,OAAO,YAAY,QAAQ,OAAO;QAC9B;QACA;IACJ;IACJ,IAAI,MAAM,IAAI,KAAK,WACf,OAAO,cAAc,QAAQ;QAAE,UAAU;IAAgB;IAC7D,IAAI,MAAM,IAAI,KAAK,QACf,OAAO,WAAW;IACtB,IAAI,MAAM,IAAI,CAAC,UAAU,CAAC,UACtB,OAAO,YAAY,QAAQ,OAAO;QAAE;IAAe;IACvD,IAAI,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,MAAM,IAAI,CAAC,UAAU,CAAC,QACvD,OAAO,aAAa,QAAQ;IAChC,IAAI,MAAM,IAAI,KAAK,UACf,OAAO,aAAa,QAAQ;QAAE;IAAe;IACjD,MAAM,IAAI,uJAAc,gBAAgB,CAAC,MAAM,IAAI;AACvD;AACA,MAAM,eAAe;AACrB,MAAM,eAAe;AAEd,SAAS,cAAc,MAAM,EAAE,UAAU,CAAC,CAAC;IAC9C,MAAM,EAAE,WAAW,KAAK,EAAE,GAAG;IAC7B,MAAM,QAAQ,OAAO,SAAS,CAAC;IAC/B,MAAM,OAAO,CAAC,UAAY,WAAW,iJAAQ,QAAQ,CAAC,WAAW;IACjE,OAAO;QAAC,KAAK,6IAAI,SAAS,CAAC,+IAAM,KAAK,CAAC,OAAO,CAAC;QAAO;KAAG;AAC7D;AAEO,SAAS,YAAY,MAAM,EAAE,KAAK,EAAE,OAAO;IAC9C,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG;IACpD,sEAAsE;IACtE,mEAAmE;IACnE,IAAI,CAAC,QAAQ;QACT,oEAAoE;QACpE,MAAM,SAAS,+IAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,yDAAyD;QACzD,MAAM,QAAQ,iBAAiB;QAC/B,MAAM,cAAc,QAAQ;QAC5B,+CAA+C;QAC/C,OAAO,WAAW,CAAC;QACnB,MAAM,SAAS,+IAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,+CAA+C;QAC/C,MAAM,eAAe,gBAAgB;QACrC,IAAI,WAAW;QACf,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,EAAE,EAAG;YAC7B,iHAAiH;YACjH,2EAA2E;YAC3E,OAAO,WAAW,CAAC,cAAc,CAAC,eAAe,IAAI,KAAK,QAAQ;YAClE,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,QAAQ,OAAO;gBACrD;gBACA,gBAAgB;YACpB;YACA,YAAY;YACZ,MAAM,IAAI,CAAC;QACf;QACA,2EAA2E;QAC3E,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC;YAAO;SAAG;IACtB;IACA,kDAAkD;IAClD,wEAAwE;IACxE,kDAAkD;IAClD,IAAI,gBAAgB,QAAQ;QACxB,mEAAmE;QACnE,MAAM,SAAS,+IAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,yDAAyD;QACzD,MAAM,QAAQ,iBAAiB;QAC/B,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,EAAE,EAAG;YAC7B,4DAA4D;YAC5D,OAAO,WAAW,CAAC,QAAQ,IAAI;YAC/B,MAAM,CAAC,KAAK,GAAG,gBAAgB,QAAQ,OAAO;gBAC1C;gBACA,gBAAgB;YACpB;YACA,MAAM,IAAI,CAAC;QACf;QACA,2EAA2E;QAC3E,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC;YAAO;SAAG;IACtB;IACA,iFAAiF;IACjF,oDAAoD;IACpD,IAAI,WAAW;IACf,MAAM,QAAQ,EAAE;IAChB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,EAAE,EAAG;QAC7B,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,QAAQ,OAAO;YACrD;YACA,gBAAgB,iBAAiB;QACrC;QACA,YAAY;QACZ,MAAM,IAAI,CAAC;IACf;IACA,OAAO;QAAC;QAAO;KAAS;AAC5B;AAEO,SAAS,WAAW,MAAM;IAC7B,OAAO;QAAC,+IAAM,SAAS,CAAC,OAAO,SAAS,CAAC,KAAK;YAAE,MAAM;QAAG;QAAI;KAAG;AACpE;AAEO,SAAS,YAAY,MAAM,EAAE,KAAK,EAAE,EAAE,cAAc,EAAE;IACzD,MAAM,CAAC,GAAG,KAAK,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC;IACnC,IAAI,CAAC,MAAM;QACP,mEAAmE;QACnE,MAAM,SAAS,+IAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,qDAAqD;QACrD,OAAO,WAAW,CAAC,iBAAiB;QACpC,MAAM,SAAS,+IAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,4CAA4C;QAC5C,IAAI,WAAW,GAAG;YACd,2EAA2E;YAC3E,OAAO,WAAW,CAAC,iBAAiB;YACpC,OAAO;gBAAC;gBAAM;aAAG;QACrB;QACA,MAAM,OAAO,OAAO,SAAS,CAAC;QAC9B,2EAA2E;QAC3E,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC,6IAAI,SAAS,CAAC;YAAO;SAAG;IACpC;IACA,MAAM,QAAQ,6IAAI,SAAS,CAAC,OAAO,SAAS,CAAC,OAAO,QAAQ,CAAC,OAAO;IACpE,OAAO;QAAC;QAAO;KAAG;AACtB;AAEO,SAAS,aAAa,MAAM,EAAE,KAAK;IACtC,MAAM,SAAS,MAAM,IAAI,CAAC,UAAU,CAAC;IACrC,MAAM,OAAO,OAAO,QAAQ,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,IAAI;IAC3D,MAAM,QAAQ,OAAO,SAAS,CAAC;IAC/B,OAAO;QACH,OAAO,KACD,+IAAM,QAAQ,CAAC,OAAO;YAAE;QAAO,KAC/B,+IAAM,QAAQ,CAAC,OAAO;YAAE;QAAO;QACrC;KACH;AACL;AAEO,SAAS,YAAY,MAAM,EAAE,KAAK,EAAE,OAAO;IAC9C,MAAM,EAAE,eAAe,EAAE,cAAc,EAAE,GAAG;IAC5C,wEAAwE;IACxE,0EAA0E;IAC1E,4EAA4E;IAC5E,0EAA0E;IAC1E,MAAM,kBAAkB,MAAM,UAAU,CAAC,MAAM,KAAK,KAAK,MAAM,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,GAAK,CAAC;IAC9F,0EAA0E;IAC1E,6BAA6B;IAC7B,MAAM,QAAQ,kBAAkB,EAAE,GAAG,CAAC;IACtC,IAAI,WAAW;IACf,2EAA2E;IAC3E,cAAc;IACd,IAAI,gBAAgB,QAAQ;QACxB,mEAAmE;QACnE,MAAM,SAAS,+IAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;QAC/C,6DAA6D;QAC7D,MAAM,QAAQ,iBAAiB;QAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,UAAU,CAAC,MAAM,EAAE,EAAE,EAAG;YAC9C,MAAM,YAAY,MAAM,UAAU,CAAC,EAAE;YACrC,OAAO,WAAW,CAAC,QAAQ;YAC3B,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,QAAQ,WAAW;gBACzD;gBACA,gBAAgB;YACpB;YACA,YAAY;YACZ,KAAK,CAAC,kBAAkB,IAAI,WAAW,KAAK,GAAG;QACnD;QACA,2EAA2E;QAC3E,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC;YAAO;SAAG;IACtB;IACA,sEAAsE;IACtE,eAAe;IACf,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,UAAU,CAAC,MAAM,EAAE,EAAE,EAAG;QAC9C,MAAM,YAAY,MAAM,UAAU,CAAC,EAAE;QACrC,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,QAAQ,WAAW;YACzD;YACA;QACJ;QACA,KAAK,CAAC,kBAAkB,IAAI,WAAW,KAAK,GAAG;QAC/C,YAAY;IAChB;IACA,OAAO;QAAC;QAAO;KAAS;AAC5B;AAEO,SAAS,aAAa,MAAM,EAAE,EAAE,cAAc,EAAE;IACnD,sCAAsC;IACtC,MAAM,SAAS,+IAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;IAC/C,yDAAyD;IACzD,MAAM,QAAQ,iBAAiB;IAC/B,OAAO,WAAW,CAAC;IACnB,MAAM,SAAS,+IAAM,QAAQ,CAAC,OAAO,SAAS,CAAC;IAC/C,2DAA2D;IAC3D,IAAI,WAAW,GAAG;QACd,OAAO,WAAW,CAAC,iBAAiB;QACpC,OAAO;YAAC;YAAI;SAAG;IACnB;IACA,MAAM,OAAO,OAAO,SAAS,CAAC,QAAQ;IACtC,MAAM,QAAQ,+IAAM,QAAQ,CAAC,+IAAM,QAAQ,CAAC;IAC5C,2EAA2E;IAC3E,OAAO,WAAW,CAAC,iBAAiB;IACpC,OAAO;QAAC;QAAO;KAAG;AACtB;AAEO,SAAS,kBAAkB,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,EAAG;IACtE,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;QACxC,mBAAmB,IAAI,CAAC,iBAAiB;YACrC;YACA,WAAW,UAAU,CAAC,EAAE;YACxB,OAAO,MAAM,CAAC,EAAE;QACpB;IACJ;IACA,OAAO;AACX;AAEO,SAAS,iBAAiB,EAAE,kBAAkB,KAAK,EAAE,WAAW,UAAU,EAAE,KAAK,EAAG;IACvF,MAAM,YAAY;IAClB,MAAM,kBAAkB,mBAAmB,UAAU,IAAI;IACzD,IAAI,iBAAiB;QACjB,MAAM,CAAC,QAAQ,KAAK,GAAG;QACvB,OAAO,YAAY,OAAO;YACtB;YACA;YACA,WAAW;gBACP,GAAG,SAAS;gBACZ;YACJ;QACJ;IACJ;IACA,IAAI,UAAU,IAAI,KAAK,SAAS;QAC5B,OAAO,YAAY,OAAO;YACtB;YACA,WAAW;QACf;IACJ;IACA,IAAI,UAAU,IAAI,KAAK,WAAW;QAC9B,OAAO,cAAc,OAAO;YACxB,UAAU;QACd;IACJ;IACA,IAAI,UAAU,IAAI,KAAK,QAAQ;QAC3B,OAAO,cAAc;IACzB;IACA,IAAI,UAAU,IAAI,CAAC,UAAU,CAAC,WAAW,UAAU,IAAI,CAAC,UAAU,CAAC,QAAQ;QACvE,MAAM,SAAS,UAAU,IAAI,CAAC,UAAU,CAAC;QACzC,MAAM,KAAK,OAAO,KAAK,CAAC,GAAG,kKAAa,IAAI,CAAC,UAAU,IAAI,KAAK,EAAE;QAClE,OAAO,aAAa,OAAO;YACvB;YACA,MAAM,OAAO;QACjB;IACJ;IACA,IAAI,UAAU,IAAI,CAAC,UAAU,CAAC,UAAU;QACpC,OAAO,YAAY,OAAO;YAAE,MAAM,UAAU,IAAI;QAAC;IACrD;IACA,IAAI,UAAU,IAAI,KAAK,UAAU;QAC7B,OAAO,aAAa;IACxB;IACA,MAAM,IAAI,uJAAc,gBAAgB,CAAC,UAAU,IAAI;AAC3D;AAEO,SAAS,OAAO,kBAAkB;IACrC,4DAA4D;IAC5D,IAAI,aAAa;IACjB,IAAK,IAAI,IAAI,GAAG,IAAI,mBAAmB,MAAM,EAAE,IAAK;QAChD,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,kBAAkB,CAAC,EAAE;QAClD,IAAI,SACA,cAAc;aAEd,cAAc,6IAAI,IAAI,CAAC;IAC/B;IACA,yDAAyD;IACzD,MAAM,mBAAmB,EAAE;IAC3B,MAAM,oBAAoB,EAAE;IAC5B,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,mBAAmB,MAAM,EAAE,IAAK;QAChD,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,kBAAkB,CAAC,EAAE;QAClD,IAAI,SAAS;YACT,iBAAiB,IAAI,CAAC,6IAAI,UAAU,CAAC,aAAa,aAAa;gBAAE,MAAM;YAAG;YAC1E,kBAAkB,IAAI,CAAC;YACvB,eAAe,6IAAI,IAAI,CAAC;QAC5B,OACK;YACD,iBAAiB,IAAI,CAAC;QAC1B;IACJ;IACA,2CAA2C;IAC3C,OAAO,6IAAI,MAAM,IAAI,qBAAqB;AAC9C;AAEO,SAAS,cAAc,KAAK,EAAE,OAAO;IACxC,MAAM,EAAE,WAAW,KAAK,EAAE,GAAG;IAC7B,iJAAQ,MAAM,CAAC,OAAO;QAAE,QAAQ;IAAS;IACzC,OAAO;QACH,SAAS;QACT,SAAS,6IAAI,OAAO,CAAC,MAAM,WAAW;IAC1C;AACJ;AAEO,SAAS,YAAY,KAAK,EAAE,OAAO;IACtC,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG;IAC/C,MAAM,UAAU,WAAW;IAC3B,IAAI,CAAC,MAAM,OAAO,CAAC,QACf,MAAM,IAAI,uJAAc,iBAAiB,CAAC;IAC9C,IAAI,CAAC,WAAW,MAAM,MAAM,KAAK,QAC7B,MAAM,IAAI,uJAAc,wBAAwB,CAAC;QAC7C,gBAAgB;QAChB,aAAa,MAAM,MAAM;QACzB,MAAM,CAAC,EAAE,UAAU,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;IACxC;IACJ,IAAI,eAAe;IACnB,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACnC,MAAM,gBAAgB,iBAAiB;YACnC;YACA;YACA,OAAO,KAAK,CAAC,EAAE;QACnB;QACA,IAAI,cAAc,OAAO,EACrB,eAAe;QACnB,mBAAmB,IAAI,CAAC;IAC5B;IACA,IAAI,WAAW,cAAc;QACzB,MAAM,OAAO,OAAO;QACpB,IAAI,SAAS;YACT,MAAM,SAAS,6IAAI,UAAU,CAAC,mBAAmB,MAAM,EAAE;gBAAE,MAAM;YAAG;YACpE,OAAO;gBACH,SAAS;gBACT,SAAS,mBAAmB,MAAM,GAAG,IAAI,6IAAI,MAAM,CAAC,QAAQ,QAAQ;YACxE;QACJ;QACA,IAAI,cACA,OAAO;YAAE,SAAS;YAAM,SAAS;QAAK;IAC9C;IACA,OAAO;QACH,SAAS;QACT,SAAS,6IAAI,MAAM,IAAI,mBAAmB,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,GAAK;IACnE;AACJ;AAEO,SAAS,YAAY,KAAK,EAAE,EAAE,IAAI,EAAE;IACvC,MAAM,GAAG,cAAc,GAAG,KAAK,KAAK,CAAC;IACrC,MAAM,YAAY,6IAAI,IAAI,CAAC;IAC3B,IAAI,CAAC,eAAe;QAChB,IAAI,SAAS;QACb,wDAAwD;QACxD,4CAA4C;QAC5C,IAAI,YAAY,OAAO,GACnB,SAAS,6IAAI,QAAQ,CAAC,QAAQ,KAAK,IAAI,CAAC,CAAC,MAAM,MAAM,GAAG,CAAC,IAAI,IAAI,MAAM;QAC3E,OAAO;YACH,SAAS;YACT,SAAS,6IAAI,MAAM,CAAC,6IAAI,OAAO,CAAC,6IAAI,UAAU,CAAC,WAAW;gBAAE,MAAM;YAAG,KAAK;QAC9E;IACJ;IACA,IAAI,cAAc,OAAO,QAAQ,CAAC,gBAC9B,MAAM,IAAI,uJAAc,sBAAsB,CAAC;QAC3C,cAAc,OAAO,QAAQ,CAAC;QAC9B;IACJ;IACJ,OAAO;QAAE,SAAS;QAAO,SAAS,6IAAI,QAAQ,CAAC;IAAO;AAC1D;AAEO,SAAS,cAAc,KAAK;IAC/B,IAAI,OAAO,UAAU,WACjB,MAAM,IAAI,gJAAO,SAAS,CAAC,CAAC,wBAAwB,EAAE,MAAM,SAAS,EAAE,OAAO,MAAM,mCAAmC,CAAC;IAC5H,OAAO;QAAE,SAAS;QAAO,SAAS,6IAAI,OAAO,CAAC,6IAAI,WAAW,CAAC;IAAQ;AAC1E;AAEO,SAAS,aAAa,KAAK,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE;IAChD,IAAI,OAAO,SAAS,UAAU;QAC1B,MAAM,MAAM,EAAE,IAAI,CAAC,OAAO,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE;QAC1D,MAAM,MAAM,SAAS,CAAC,MAAM,EAAE,GAAG,EAAE;QACnC,IAAI,QAAQ,OAAO,QAAQ,KACvB,MAAM,IAAI,6IAAI,sBAAsB,CAAC;YACjC,KAAK,IAAI,QAAQ;YACjB,KAAK,IAAI,QAAQ;YACjB;YACA,MAAM,OAAO;YACb,OAAO,MAAM,QAAQ;QACzB;IACR;IACA,OAAO;QACH,SAAS;QACT,SAAS,6IAAI,UAAU,CAAC,OAAO;YAC3B,MAAM;YACN;QACJ;IACJ;AACJ;AAEO,SAAS,aAAa,KAAK;IAC9B,MAAM,WAAW,6IAAI,UAAU,CAAC;IAChC,MAAM,cAAc,KAAK,IAAI,CAAC,6IAAI,IAAI,CAAC,YAAY;IACnD,MAAM,QAAQ,EAAE;IAChB,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,IAAK;QAClC,MAAM,IAAI,CAAC,6IAAI,QAAQ,CAAC,6IAAI,KAAK,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI;IAClE;IACA,OAAO;QACH,SAAS;QACT,SAAS,6IAAI,MAAM,CAAC,6IAAI,QAAQ,CAAC,6IAAI,UAAU,CAAC,6IAAI,IAAI,CAAC,WAAW;YAAE,MAAM;QAAG,QAAQ;IAC3F;AACJ;AAEO,SAAS,YAAY,KAAK,EAAE,OAAO;IACtC,MAAM,EAAE,eAAe,EAAE,SAAS,EAAE,GAAG;IACvC,IAAI,UAAU;IACd,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,UAAU,CAAC,MAAM,EAAE,IAAK;QAClD,MAAM,SAAS,UAAU,UAAU,CAAC,EAAE;QACtC,MAAM,QAAQ,MAAM,OAAO,CAAC,SAAS,IAAI,OAAO,IAAI;QACpD,MAAM,gBAAgB,iBAAiB;YACnC;YACA,WAAW;YACX,OAAO,KAAK,CAAC,MAAM;QACvB;QACA,mBAAmB,IAAI,CAAC;QACxB,IAAI,cAAc,OAAO,EACrB,UAAU;IAClB;IACA,OAAO;QACH;QACA,SAAS,UACH,OAAO,sBACP,6IAAI,MAAM,IAAI,mBAAmB,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,GAAK;IAChE;AACJ;AAEO,SAAS,mBAAmB,IAAI;IACnC,MAAM,UAAU,KAAK,KAAK,CAAC;IAC3B,OAAO,UAEC;QAAC,OAAO,CAAC,EAAE,GAAG,OAAO,OAAO,CAAC,EAAE,IAAI;QAAM,OAAO,CAAC,EAAE;KAAC,GACtD;AACV;AAEO,SAAS,gBAAgB,KAAK;IACjC,MAAM,EAAE,IAAI,EAAE,GAAG;IACjB,IAAI,SAAS,UACT,OAAO;IACX,IAAI,SAAS,SACT,OAAO;IACX,IAAI,KAAK,QAAQ,CAAC,OACd,OAAO;IACX,IAAI,SAAS,SACT,OAAO,MAAM,UAAU,EAAE,KAAK;IAClC,MAAM,kBAAkB,mBAAmB,MAAM,IAAI;IACrD,IAAI,mBACA,gBAAgB;QACZ,GAAG,KAAK;QACR,MAAM,eAAe,CAAC,EAAE;IAC5B,IACA,OAAO;IACX,OAAO;AACX,EACA,yCAAyC"}},
    {"offset": {"line": 6064, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6069, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/AbiParameters.js"],"sourcesContent":["import * as abitype from 'abitype';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Solidity from './Solidity.js';\nimport * as internal from './internal/abiParameters.js';\nimport * as Cursor from './internal/cursor.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data;\n    const cursor = Cursor.create(bytes);\n    if (Bytes.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (Bytes.size(bytes) && Bytes.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : Hex.fromBytes(data),\n            parameters: parameters,\n            size: Bytes.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = internal.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nexport function encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = internal.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = internal.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nexport function encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return Hex.concat(...data);\n}\n(function (encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            Address.assert(address);\n            return Hex.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return Hex.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return Hex.padLeft(Hex.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(Solidity.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits) / 8;\n            return Hex.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(Solidity.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size),\n                    value: value,\n                });\n            return Hex.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(Solidity.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return Hex.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nexport function format(parameters) {\n    return abitype.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nexport function from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                               2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nexport class DataSizeTooSmallError extends Errors.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                             zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nexport class ZeroDataError extends Errors.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                                expected: 3    length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                           length: 3\n * ```\n */\nexport class ArrayLengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                             expected: 8 bytes    size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                         size: 8 bytes\n * ```\n */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${Hex.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nexport class LengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nexport class InvalidArrayError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                               invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nexport class InvalidTypeError extends Errors.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiParameters.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6291, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6296, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/erc6492/WrappedSignature.js"],"sourcesContent":["import * as AbiParameters from '../core/AbiParameters.js';\nimport * as Errors from '../core/Errors.js';\nimport * as Hex from '../core/Hex.js';\nimport * as Signature from '../core/Signature.js';\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nexport const magicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nexport const universalSignatureValidatorBytecode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nexport const universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        outputs: [\n            {\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n        name: 'isValidSig',\n    },\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * WrappedSignature.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nexport function assert(wrapped) {\n    if (Hex.slice(wrapped, -32) !== magicBytes)\n        throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = WrappedSignature.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = WrappedSignature.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function from(wrapped) {\n    if (typeof wrapped === 'string')\n        return fromHex(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * const { data, signature, to } = WrappedSignature.fromHex('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function fromHex(wrapped) {\n    assert(wrapped);\n    const [to, data, signature_hex] = AbiParameters.decode(AbiParameters.from('address, bytes, bytes'), wrapped);\n    const signature = Signature.fromHex(signature_hex);\n    return { data, signature, to };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = WrappedSignature.toHex({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nexport function toHex(value) {\n    const { data, signature, to } = value;\n    return Hex.concat(AbiParameters.encode(AbiParameters.from('address, bytes, bytes'), [\n        to,\n        data,\n        Signature.toHex(signature),\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * const valid = WrappedSignature.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nexport function validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WrappedSignature.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=WrappedSignature.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAOO,MAAM,aAAa;AAInB,MAAM,sCAAsC;AAM5C,MAAM,iCAAiC;IAC1C;QACI,QAAQ;YACJ;gBACI,MAAM;gBACN,MAAM;YACV;YACA;gBACI,MAAM;gBACN,MAAM;YACV;YACA;gBACI,MAAM;gBACN,MAAM;YACV;SACH;QACD,iBAAiB;QACjB,MAAM;IACV;IACA;QACI,QAAQ;YACJ;gBACI,MAAM;gBACN,MAAM;YACV;YACA;gBACI,MAAM;gBACN,MAAM;YACV;YACA;gBACI,MAAM;gBACN,MAAM;YACV;SACH;QACD,SAAS;YACL;gBACI,MAAM;YACV;SACH;QACD,iBAAiB;QACjB,MAAM;QACN,MAAM;IACV;CACH;AAcM,SAAS,OAAO,OAAO;IAC1B,IAAI,6IAAI,KAAK,CAAC,SAAS,CAAC,QAAQ,YAC5B,MAAM,IAAI,6BAA6B;AAC/C;AA+BO,SAAS,KAAK,OAAO;IACxB,IAAI,OAAO,YAAY,UACnB,OAAO,QAAQ;IACnB,OAAO;AACX;AAcO,SAAS,QAAQ,OAAO;IAC3B,OAAO;IACP,MAAM,CAAC,IAAI,MAAM,cAAc,GAAG,uJAAc,MAAM,CAAC,uJAAc,IAAI,CAAC,0BAA0B;IACpG,MAAM,YAAY,mJAAU,OAAO,CAAC;IACpC,OAAO;QAAE;QAAM;QAAW;IAAG;AACjC;AAwBO,SAAS,MAAM,KAAK;IACvB,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,EAAE,GAAG;IAChC,OAAO,6IAAI,MAAM,CAAC,uJAAc,MAAM,CAAC,uJAAc,IAAI,CAAC,0BAA0B;QAChF;QACA;QACA,mJAAU,KAAK,CAAC;KACnB,GAAG;AACR;AAeO,SAAS,SAAS,OAAO;IAC5B,IAAI;QACA,OAAO;QACP,OAAO;IACX,EACA,OAAM;QACF,OAAO;IACX;AACJ;AAEO,MAAM,qCAAqC,gJAAO,SAAS;IAC9D,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,CAAC,QAAQ,EAAE,QAAQ,4CAA4C,CAAC;QACtE,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,4CAA4C"}},
    {"offset": {"line": 6406, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6422, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/erc6492/SignatureErc6492.js"],"sourcesContent":["import * as AbiParameters from '../core/AbiParameters.js';\nimport * as Errors from '../core/Errors.js';\nimport * as Hex from '../core/Hex.js';\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nexport const magicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nexport const universalSignatureValidatorBytecode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nexport const universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        outputs: [\n            {\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n        name: 'isValidSig',\n    },\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * SignatureErc6492.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nexport function assert(wrapped) {\n    if (Hex.slice(wrapped, -32) !== magicBytes)\n        throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc6492.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc6492.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function from(wrapped) {\n    if (typeof wrapped === 'string')\n        return unwrap(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const { data, signature, to } = SignatureErc6492.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function unwrap(wrapped) {\n    assert(wrapped);\n    const [to, data, signature] = AbiParameters.decode(AbiParameters.from('address, bytes, bytes'), wrapped);\n    return { data, signature, to };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc6492.wrap({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nexport function wrap(value) {\n    const { data, signature, to } = value;\n    return Hex.concat(AbiParameters.encode(AbiParameters.from('address, bytes, bytes'), [\n        to,\n        data,\n        signature,\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const valid = SignatureErc6492.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nexport function validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc6492.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc6492.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAMO,MAAM,aAAa;AAInB,MAAM,sCAAsC;AAM5C,MAAM,iCAAiC;IAC1C;QACI,QAAQ;YACJ;gBACI,MAAM;gBACN,MAAM;YACV;YACA;gBACI,MAAM;gBACN,MAAM;YACV;YACA;gBACI,MAAM;gBACN,MAAM;YACV;SACH;QACD,iBAAiB;QACjB,MAAM;IACV;IACA;QACI,QAAQ;YACJ;gBACI,MAAM;gBACN,MAAM;YACV;YACA;gBACI,MAAM;gBACN,MAAM;YACV;YACA;gBACI,MAAM;gBACN,MAAM;YACV;SACH;QACD,SAAS;YACL;gBACI,MAAM;YACV;SACH;QACD,iBAAiB;QACjB,MAAM;QACN,MAAM;IACV;CACH;AAcM,SAAS,OAAO,OAAO;IAC1B,IAAI,qKAAI,KAAK,CAAC,SAAS,CAAC,QAAQ,YAC5B,MAAM,IAAI,6BAA6B;AAC/C;AA+BO,SAAS,KAAK,OAAO;IACxB,IAAI,OAAO,YAAY,UACnB,OAAO,OAAO;IAClB,OAAO;AACX;AAcO,SAAS,OAAO,OAAO;IAC1B,OAAO;IACP,MAAM,CAAC,IAAI,MAAM,UAAU,GAAG,+KAAc,MAAM,CAAC,+KAAc,IAAI,CAAC,0BAA0B;IAChG,OAAO;QAAE;QAAM;QAAW;IAAG;AACjC;AAwBO,SAAS,KAAK,KAAK;IACtB,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,EAAE,GAAG;IAChC,OAAO,qKAAI,MAAM,CAAC,+KAAc,MAAM,CAAC,+KAAc,IAAI,CAAC,0BAA0B;QAChF;QACA;QACA;KACH,GAAG;AACR;AAeO,SAAS,SAAS,OAAO;IAC5B,IAAI;QACA,OAAO;QACP,OAAO;IACX,EACA,OAAM;QACF,OAAO;IACX;AACJ;AAEO,MAAM,qCAAqC,wKAAO,SAAS;IAC9D,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,CAAC,QAAQ,EAAE,QAAQ,4CAA4C,CAAC;QACtE,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,4CAA4C"}},
    {"offset": {"line": 6529, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6544, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/internal/abiItem.js"],"sourcesContent":["import * as Address from '../Address.js';\nimport * as Errors from '../Errors.js';\n/** @internal */\nexport function normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new Errors.BaseError('Unable to normalize signature.');\n    return result;\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return Address.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map"],"names":[],"mappings":";;;;;;;;;;AAGO,SAAS,mBAAmB,SAAS;IACxC,IAAI,SAAS;IACb,IAAI,UAAU;IACd,IAAI,QAAQ;IACZ,IAAI,SAAS;IACb,IAAI,QAAQ;IACZ,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QACvC,MAAM,OAAO,SAAS,CAAC,EAAE;QACzB,0DAA0D;QAC1D,IAAI;YAAC;YAAK;YAAK;SAAI,CAAC,QAAQ,CAAC,OACzB,SAAS;QACb,uEAAuE;QACvE,IAAI,SAAS,KACT;QACJ,IAAI,SAAS,KACT;QACJ,2DAA2D;QAC3D,IAAI,CAAC,QACD;QACJ,kDAAkD;QAClD,IAAI,UAAU,GAAG;YACb,IAAI,SAAS,OAAO;gBAAC;gBAAS;gBAAY;gBAAS;aAAG,CAAC,QAAQ,CAAC,SAC5D,SAAS;iBACR;gBACD,UAAU;gBACV,+DAA+D;gBAC/D,IAAI,SAAS,KAAK;oBACd,QAAQ;oBACR;gBACJ;YACJ;YACA;QACJ;QACA,gBAAgB;QAChB,IAAI,SAAS,KAAK;YACd,wGAAwG;YACxG,IAAI,SAAS,CAAC,IAAI,EAAE,KAAK,OAAO,YAAY,OAAO,YAAY,MAAM;gBACjE,UAAU;gBACV,SAAS;YACb;YACA;QACJ;QACA,UAAU;QACV,WAAW;IACf;IACA,IAAI,CAAC,OACD,MAAM,IAAI,gJAAO,SAAS,CAAC;IAC/B,OAAO;AACX;AAEO,SAAS,YAAY,GAAG,EAAE,YAAY;IACzC,MAAM,UAAU,OAAO;IACvB,MAAM,mBAAmB,aAAa,IAAI;IAC1C,OAAQ;QACJ,KAAK;YACD,OAAO,iJAAQ,QAAQ,CAAC,KAAK;gBAAE,QAAQ;YAAM;QACjD,KAAK;YACD,OAAO,YAAY;QACvB,KAAK;YACD,OAAO,YAAY;QACvB,KAAK;YACD,OAAO,YAAY;QACvB;YAAS;gBACL,IAAI,qBAAqB,WAAW,gBAAgB,cAChD,OAAO,OAAO,MAAM,CAAC,aAAa,UAAU,EAAE,KAAK,CAAC,CAAC,WAAW;oBAC5D,OAAO,YAAY,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE;gBAClD;gBACJ,iFAAiF;gBACjF,2BAA2B;gBAC3B,IAAI,+HAA+H,IAAI,CAAC,mBACpI,OAAO,YAAY,YAAY,YAAY;gBAC/C,sDAAsD;gBACtD,2BAA2B;gBAC3B,IAAI,uCAAuC,IAAI,CAAC,mBAC5C,OAAO,YAAY,YAAY,eAAe;gBAClD,6DAA6D;gBAC7D,2BAA2B;gBAC3B,IAAI,oCAAoC,IAAI,CAAC,mBAAmB;oBAC5D,OAAQ,MAAM,OAAO,CAAC,QAClB,IAAI,KAAK,CAAC,CAAC,IAAM,YAAY,GAAG;4BAC5B,GAAG,YAAY;4BACf,yCAAyC;4BACzC,MAAM,iBAAiB,OAAO,CAAC,oBAAoB;wBACvD;gBACR;gBACA,OAAO;YACX;IACJ;AACJ;AAEO,SAAS,kBAAkB,gBAAgB,EAAE,gBAAgB,EAAE,IAAI;IACtE,IAAK,MAAM,kBAAkB,iBAAkB;QAC3C,MAAM,kBAAkB,gBAAgB,CAAC,eAAe;QACxD,MAAM,kBAAkB,gBAAgB,CAAC,eAAe;QACxD,IAAI,gBAAgB,IAAI,KAAK,WACzB,gBAAgB,IAAI,KAAK,WACzB,gBAAgB,mBAChB,gBAAgB,iBAChB,OAAO,kBAAkB,gBAAgB,UAAU,EAAE,gBAAgB,UAAU,EAAE,IAAI,CAAC,eAAe;QACzG,MAAM,QAAQ;YAAC,gBAAgB,IAAI;YAAE,gBAAgB,IAAI;SAAC;QAC1D,MAAM,YAAY,AAAC,CAAA;YACf,IAAI,MAAM,QAAQ,CAAC,cAAc,MAAM,QAAQ,CAAC,YAC5C,OAAO;YACX,IAAI,MAAM,QAAQ,CAAC,cAAc,MAAM,QAAQ,CAAC,WAC5C,OAAO,iJAAQ,QAAQ,CAAC,IAAI,CAAC,eAAe,EAAE;gBAC1C,QAAQ;YACZ;YACJ,IAAI,MAAM,QAAQ,CAAC,cAAc,MAAM,QAAQ,CAAC,UAC5C,OAAO,iJAAQ,QAAQ,CAAC,IAAI,CAAC,eAAe,EAAE;gBAC1C,QAAQ;YACZ;YACJ,OAAO;QACX,CAAA;QACA,IAAI,WACA,OAAO;IACf;IACA;AACJ,EACA,mCAAmC"}},
    {"offset": {"line": 6667, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6672, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/AbiItem.js"],"sourcesContent":["import * as abitype from 'abitype';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/abiItem.js';\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format(abiItem) {\n    return abitype.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = Hex.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === Hex.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return internal.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem) {\n    return Hex.slice(getSignatureHash(abiItem), 0, 4);\n}\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */\nexport function getSignature(abiItem) {\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype.formatAbiItem(abiItem);\n    })();\n    return internal.normalizeSignature(signature);\n}\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */\nexport function getSignatureHash(abiItem) {\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return Hash.keccak256(Hex.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiItem.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAsCO,SAAS,OAAO,OAAO;IAC1B,OAAO,8KAAQ,aAAa,CAAC;AACjC;AAwGO,SAAS,KAAK,OAAO,EAAE,UAAU,CAAC,CAAC;IACtC,MAAM,EAAE,UAAU,IAAI,EAAE,GAAG;IAC3B,MAAM,OAAO,AAAC,CAAA;QACV,IAAI,MAAM,OAAO,CAAC,UACd,OAAO,8KAAQ,YAAY,CAAC;QAChC,IAAI,OAAO,YAAY,UACnB,OAAO,8KAAQ,YAAY,CAAC;QAChC,OAAO;IACX,CAAA;IACA,OAAO;QACH,GAAG,IAAI;QACP,GAAI,UAAU;YAAE,MAAM,iBAAiB;QAAM,IAAI,CAAC,CAAC;IACvD;AACJ;AAoEO,SAAS,QAAQ,GAAG,EAAE,IAAI,EAAE,OAAO;IACtC,MAAM,EAAE,OAAO,EAAE,EAAE,UAAU,IAAI,EAAE,GAAI,WACnC,CAAC;IACL,MAAM,aAAa,6IAAI,QAAQ,CAAC,MAAM;QAAE,QAAQ;IAAM;IACtD,MAAM,WAAW,IAAI,MAAM,CAAC,CAAC;QACzB,IAAI,YAAY;YACZ,IAAI,QAAQ,IAAI,KAAK,cAAc,QAAQ,IAAI,KAAK,SAChD,OAAO,YAAY,aAAa,6IAAI,KAAK,CAAC,MAAM,GAAG;YACvD,IAAI,QAAQ,IAAI,KAAK,SACjB,OAAO,iBAAiB,aAAa;YACzC,OAAO;QACX;QACA,OAAO,UAAU,WAAW,QAAQ,IAAI,KAAK;IACjD;IACA,IAAI,SAAS,MAAM,KAAK,GACpB,MAAM,IAAI,cAAc;QAAE,MAAM;IAAK;IACzC,IAAI,SAAS,MAAM,KAAK,GACpB,OAAO;QACH,GAAG,QAAQ,CAAC,EAAE;QACd,GAAI,UAAU;YAAE,MAAM,iBAAiB,QAAQ,CAAC,EAAE;QAAE,IAAI,CAAC,CAAC;IAC9D;IACJ,IAAI,iBAAiB;IACrB,KAAK,MAAM,WAAW,SAAU;QAC5B,IAAI,CAAC,CAAC,YAAY,OAAO,GACrB;QACJ,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;YAC5B,IAAI,CAAC,QAAQ,MAAM,IAAI,QAAQ,MAAM,CAAC,MAAM,KAAK,GAC7C,OAAO;gBACH,GAAG,OAAO;gBACV,GAAI,UAAU;oBAAE,MAAM,iBAAiB;gBAAS,IAAI,CAAC,CAAC;YAC1D;YACJ;QACJ;QACA,IAAI,CAAC,QAAQ,MAAM,EACf;QACJ,IAAI,QAAQ,MAAM,CAAC,MAAM,KAAK,GAC1B;QACJ,IAAI,QAAQ,MAAM,CAAC,MAAM,KAAK,KAAK,MAAM,EACrC;QACJ,MAAM,UAAU,KAAK,KAAK,CAAC,CAAC,KAAK;YAC7B,MAAM,eAAe,YAAY,WAAW,QAAQ,MAAM,CAAC,MAAM;YACjE,IAAI,CAAC,cACD,OAAO;YACX,OAAO,6JAAS,WAAW,CAAC,KAAK;QACrC;QACA,IAAI,SAAS;YACT,wFAAwF;YACxF,IAAI,kBACA,YAAY,kBACZ,eAAe,MAAM,EAAE;gBACvB,MAAM,iBAAiB,6JAAS,iBAAiB,CAAC,QAAQ,MAAM,EAAE,eAAe,MAAM,EAAE;gBACzF,IAAI,gBACA,MAAM,IAAI,eAAe;oBACrB;oBACA,MAAM,cAAc,CAAC,EAAE;gBAC3B,GAAG;oBACC,SAAS;oBACT,MAAM,cAAc,CAAC,EAAE;gBAC3B;YACR;YACA,iBAAiB;QACrB;IACJ;IACA,MAAM,UAAU,AAAC,CAAA;QACb,IAAI,gBACA,OAAO;QACX,MAAM,CAAC,SAAS,GAAG,UAAU,GAAG;QAChC,OAAO;YAAE,GAAG,OAAO;YAAE;QAAU;IACnC,CAAA;IACA,IAAI,CAAC,SACD,MAAM,IAAI,cAAc;QAAE,MAAM;IAAK;IACzC,OAAO;QACH,GAAG,OAAO;QACV,GAAI,UAAU;YAAE,MAAM,iBAAiB;QAAS,IAAI,CAAC,CAAC;IAC1D;AACJ;AA+BO,SAAS,YAAY,OAAO;IAC/B,OAAO,6IAAI,KAAK,CAAC,iBAAiB,UAAU,GAAG;AACnD;AA6BO,SAAS,aAAa,OAAO;IAChC,MAAM,YAAY,AAAC,CAAA;QACf,IAAI,OAAO,YAAY,UACnB,OAAO;QACX,OAAO,8KAAQ,aAAa,CAAC;IACjC,CAAA;IACA,OAAO,6JAAS,kBAAkB,CAAC;AACvC;AAiCO,SAAS,iBAAiB,OAAO;IACpC,IAAI,OAAO,YAAY,YAAY,UAAU,WAAW,QAAQ,IAAI,EAChE,OAAO,QAAQ,IAAI;IACvB,OAAO,8IAAK,SAAS,CAAC,6IAAI,UAAU,CAAC,aAAa;AACtD;AAwCO,MAAM,uBAAuB,gJAAO,SAAS;IAChD,YAAY,CAAC,EAAE,CAAC,CAAE;QACd,KAAK,CAAC,kDAAkD;YACpD,cAAc;gBACV,kEAAkE;gBAClE,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,QAAQ,EAAE,6JAAS,kBAAkB,CAAC,8KAAQ,aAAa,CAAC,EAAE,OAAO,GAAG,OAAO,CAAC;gBAC5F,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,QAAQ,EAAE,6JAAS,kBAAkB,CAAC,8KAAQ,aAAa,CAAC,EAAE,OAAO,GAAG,EAAE,CAAC;gBACvF;gBACA;gBACA;aACH;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AAiCO,MAAM,sBAAsB,gJAAO,SAAS;IAC/C,YAAY,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,MAAM,EAAG,CAAE;QACxC,MAAM,WAAW,AAAC,CAAA;YACd,IAAI,MACA,OAAO,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;YACjC,IAAI,MACA,OAAO,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;YACjC,OAAO;QACX,CAAA;QACA,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,SAAS,WAAW,CAAC;QACzC,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AA+BO,MAAM,iCAAiC,gJAAO,SAAS;IAC1D,YAAY,EAAE,IAAI,EAAE,CAAE;QAClB,KAAK,CAAC,CAAC,qDAAqD,EAAE,6IAAI,IAAI,CAAC,MAAM,SAAS,EAAE,KAAK,GAAG,CAAC;QACjG,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,mCAAmC"}},
    {"offset": {"line": 6847, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6852, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/AbiFunction.js"],"sourcesContent":["import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n/**\n * ABI-decodes function arguments according to the ABI Item's input types (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n *\n * const input = AbiFunction.decodeData(approve, data) // [!code focus]\n * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * ```\n *\n * @param abiFunction - The ABI Item to decode.\n * @param data - The data to decode.\n */\nexport function decodeData(abiFunction, data) {\n    const { overloads } = abiFunction;\n    if (Hex.size(data) < 4)\n        throw new AbiItem.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (Hex.size(data) <= 4)\n        return undefined;\n    return AbiParameters.decode(item.inputs, Hex.slice(data, 4));\n}\n/**\n * ABI-decodes a function's result according to the ABI Item's output types (`outputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function return values (e.g. the response of an `eth_call` or the `input` property of a Transaction).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const totalSupply = AbiFunction.fromAbi(erc20Abi, 'totalSupply') // [!code hl]\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.decodeResult` to decode the result of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   balanceOf,\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B']\n * )\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output. // [!code focus]\n * const balance = AbiFunction.decodeResult(balanceOf, response) // [!code focus]\n * // @log: 42n\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to decode\n * @param data - ABI-encoded function output\n * @param options - Decoding options\n * @returns Decoded function output\n */\nexport function decodeResult(abiFunction, data, options = {}) {\n    const values = AbiParameters.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n/**\n * ABI-encodes function arguments (`inputs`), prefixed with the 4 byte function selector.\n *\n * :::tip\n *\n * This function is typically used to encode a contract function and its arguments for contract calls (e.g. `data` parameter of an `eth_call` or `eth_sendTransaction`).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const approve = AbiFunction.fromAbi(erc20Abi, 'approve') // [!code hl]\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.encodeData` to encode the input of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input. // [!code focus]\n * const data = AbiFunction.encodeData( // [!code focus]\n *   balanceOf, // [!code focus]\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B'] // [!code focus]\n * ) // [!code focus]\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output.\n * const balance = AbiFunction.decodeResult(balanceOf, response)\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to encode\n * @param args - Function arguments\n * @returns ABI-encoded function name and arguments\n */\nexport function encodeData(abiFunction, ...args) {\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args: args[0],\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0\n        ? AbiParameters.encode(item.inputs, args[0])\n        : undefined;\n    return data ? Hex.concat(selector, data) : selector;\n}\n/**\n * ABI-encodes a function's result (`outputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n * const output = AbiFunction.decodeResult(totalSupply, '0x000000000000000000000000000000000000000000000000000000000000002a')\n * // 42n\n *\n * const data = AbiFunction.encodeResult(totalSupply, 42n) // [!code focus]\n * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'\n * ```\n *\n * @param abiFunction - The ABI item to encode the function output for.\n * @param output - The function output to encode.\n * @param options - Encoding options.\n * @returns The encoded function output.\n */\nexport function encodeResult(abiFunction, output, options = {}) {\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return AbiParameters.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nexport function format(abiFunction) {\n    return abitype.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nexport function from(abiFunction, options = {}) {\n    return AbiItem.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n    const item = AbiItem.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new AbiItem.NotFoundError({ name, type: 'function' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem) {\n    return AbiItem.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AA0BO,SAAS,WAAW,WAAW,EAAE,IAAI;IACxC,MAAM,EAAE,SAAS,EAAE,GAAG;IACtB,IAAI,6IAAI,IAAI,CAAC,QAAQ,GACjB,MAAM,IAAI,iJAAQ,wBAAwB,CAAC;QAAE;IAAK;IACtD,IAAI,YAAY,MAAM,CAAC,MAAM,KAAK,GAC9B,OAAO;IACX,MAAM,OAAO,YACP,QAAQ;QAAC;WAAgB;KAAU,EAAE,QACrC;IACN,IAAI,6IAAI,IAAI,CAAC,SAAS,GAClB,OAAO;IACX,OAAO,uJAAc,MAAM,CAAC,KAAK,MAAM,EAAE,6IAAI,KAAK,CAAC,MAAM;AAC7D;AAiGO,SAAS,aAAa,WAAW,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IACxD,MAAM,SAAS,uJAAc,MAAM,CAAC,YAAY,OAAO,EAAE,MAAM;IAC/D,IAAI,UAAU,OAAO,IAAI,CAAC,QAAQ,MAAM,KAAK,GACzC,OAAO;IACX,IAAI,UAAU,OAAO,IAAI,CAAC,QAAQ,MAAM,KAAK,GAAG;QAC5C,IAAI,MAAM,OAAO,CAAC,SACd,OAAO,MAAM,CAAC,EAAE;QACpB,OAAO,OAAO,MAAM,CAAC,OAAO,CAAC,EAAE;IACnC;IACA,OAAO;AACX;AAiGO,SAAS,WAAW,WAAW,EAAE,GAAG,IAAI;IAC3C,MAAM,EAAE,SAAS,EAAE,GAAG;IACtB,MAAM,OAAO,YACP,QAAQ;QAAC;WAAgB;KAAU,EAAE,YAAY,IAAI,EAAE;QACrD,MAAM,IAAI,CAAC,EAAE;IACjB,KACE;IACN,MAAM,WAAW,YAAY;IAC7B,MAAM,OAAO,KAAK,MAAM,GAAG,IACrB,uJAAc,MAAM,CAAC,KAAK,MAAM,EAAE,IAAI,CAAC,EAAE,IACzC;IACN,OAAO,OAAO,6IAAI,MAAM,CAAC,UAAU,QAAQ;AAC/C;AAqBO,SAAS,aAAa,WAAW,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;IAC1D,MAAM,EAAE,KAAK,OAAO,EAAE,GAAG;IACzB,MAAM,SAAS,AAAC,CAAA;QACZ,IAAI,YAAY,OAAO,CAAC,MAAM,KAAK,GAC/B,OAAO;YAAC;SAAO;QACnB,IAAI,MAAM,OAAO,CAAC,SACd,OAAO;QACX,IAAI,OAAO,UACP,OAAO,OAAO,MAAM,CAAC;QACzB,OAAO;YAAC;SAAO;IACnB,CAAA;IACA,OAAO,uJAAc,MAAM,CAAC,YAAY,OAAO,EAAE;AACrD;AAkCO,SAAS,OAAO,WAAW;IAC9B,OAAO,8KAAQ,aAAa,CAAC;AACjC;AAwGO,SAAS,KAAK,WAAW,EAAE,UAAU,CAAC,CAAC;IAC1C,OAAO,iJAAQ,IAAI,CAAC,aAAa;AACrC;AAkEO,SAAS,QAAQ,GAAG,EAAE,IAAI,EAAE,OAAO;IACtC,MAAM,OAAO,iJAAQ,OAAO,CAAC,KAAK,MAAM;IACxC,IAAI,KAAK,IAAI,KAAK,YACd,MAAM,IAAI,iJAAQ,aAAa,CAAC;QAAE;QAAM,MAAM;IAAW;IAC7D,OAAO;AACX;AA+BO,SAAS,YAAY,OAAO;IAC/B,OAAO,iJAAQ,WAAW,CAAC;AAC/B,EACA,uCAAuC"}},
    {"offset": {"line": 6936, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6941, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/internal/abiItem.js"],"sourcesContent":["import * as Address from '../Address.js';\nimport * as Errors from '../Errors.js';\n/** @internal */\nexport function normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new Errors.BaseError('Unable to normalize signature.');\n    return result;\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return Address.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7064, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7069, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/AbiItem.js"],"sourcesContent":["import * as abitype from 'abitype';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/abiItem.js';\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format(abiItem) {\n    return abitype.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = Hex.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === Hex.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return internal.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSelector(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    return Hex.slice(getSignatureHash(abiItem), 0, 4);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignature(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype.formatAbiItem(abiItem);\n    })();\n    return internal.normalizeSignature(signature);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignatureHash(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return Hash.keccak256(Hex.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiItem.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7270, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/AbiFunction.js"],"sourcesContent":["import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decodeData(...parameters) {\n    const [abiFunction, data] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data] = parameters;\n            return [fromAbi(abi, name), data];\n        }\n        return parameters;\n    })();\n    const { overloads } = abiFunction;\n    if (Hex.size(data) < 4)\n        throw new AbiItem.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (Hex.size(data) <= 4)\n        return undefined;\n    return AbiParameters.decode(item.inputs, Hex.slice(data, 4));\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decodeResult(...parameters) {\n    const [abiFunction, data, options = {}] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data, options] = parameters;\n            return [fromAbi(abi, name), data, options];\n        }\n        return parameters;\n    })();\n    const values = AbiParameters.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encodeData(...parameters) {\n    const [abiFunction, args = []] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, args] = parameters;\n            return [fromAbi(abi, name, { args }), args];\n        }\n        const [abiFunction, args] = parameters;\n        return [abiFunction, args];\n    })();\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args,\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0 ? AbiParameters.encode(item.inputs, args) : undefined;\n    return data ? Hex.concat(selector, data) : selector;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encodeResult(...parameters) {\n    const [abiFunction, output, options = {}] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, output, options] = parameters;\n            return [fromAbi(abi, name), output, options];\n        }\n        return parameters;\n    })();\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return AbiParameters.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nexport function format(abiFunction) {\n    return abitype.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nexport function from(abiFunction, options = {}) {\n    return AbiItem.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n    const item = AbiItem.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new AbiItem.NotFoundError({ name, type: 'function' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem) {\n    return AbiItem.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7402, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7407, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ox/_esm/core/AbiConstructor.js"],"sourcesContent":["import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n/** @internal */\nexport function decode(abiConstructor, options) {\n    const { bytecode } = options;\n    if (abiConstructor.inputs.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return AbiParameters.decode(abiConstructor.inputs, data);\n}\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nexport function encode(abiConstructor, options) {\n    const { bytecode, args } = options;\n    return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? AbiParameters.encode(abiConstructor.inputs, args)\n        : '0x');\n}\n/** @internal */\nexport function format(abiConstructor) {\n    return abitype.formatAbiItem(abiConstructor);\n}\n/** @internal */\nexport function from(abiConstructor) {\n    return AbiItem.from(abiConstructor);\n}\n/** @internal */\nexport function fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new AbiItem.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAKO,SAAS,OAAO,cAAc,EAAE,OAAO;IAC1C,MAAM,EAAE,QAAQ,EAAE,GAAG;IACrB,IAAI,eAAe,MAAM,CAAC,MAAM,KAAK,GACjC,OAAO;IACX,MAAM,OAAO,QAAQ,IAAI,CAAC,OAAO,CAAC,UAAU;IAC5C,OAAO,uJAAc,MAAM,CAAC,eAAe,MAAM,EAAE;AACvD;AAsDO,SAAS,OAAO,cAAc,EAAE,OAAO;IAC1C,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG;IAC3B,OAAO,6IAAI,MAAM,CAAC,UAAU,eAAe,MAAM,EAAE,UAAU,MAAM,SAC7D,uJAAc,MAAM,CAAC,eAAe,MAAM,EAAE,QAC5C;AACV;AAEO,SAAS,OAAO,cAAc;IACjC,OAAO,8KAAQ,aAAa,CAAC;AACjC;AAEO,SAAS,KAAK,cAAc;IAC/B,OAAO,iJAAQ,IAAI,CAAC;AACxB;AAEO,SAAS,QAAQ,GAAG;IACvB,MAAM,OAAO,IAAI,IAAI,CAAC,CAAC,OAAS,KAAK,IAAI,KAAK;IAC9C,IAAI,CAAC,MACD,MAAM,IAAI,iJAAQ,aAAa,CAAC;QAAE,MAAM;IAAc;IAC1D,OAAO;AACX,EACA,0CAA0C"}},
    {"offset": {"line": 7446, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7451, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/ox/_esm/core/AbiConstructor.js"],"sourcesContent":["import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(...parameters) {\n    const [abiConstructor, options] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [fromAbi(abi), options];\n        }\n        return parameters;\n    })();\n    const { bytecode } = options;\n    if (abiConstructor.inputs.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return AbiParameters.decode(abiConstructor.inputs, data);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(...parameters) {\n    const [abiConstructor, options] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [fromAbi(abi), options];\n        }\n        return parameters;\n    })();\n    const { bytecode, args } = options;\n    return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? AbiParameters.encode(abiConstructor.inputs, args)\n        : '0x');\n}\n/** @internal */\nexport function format(abiConstructor) {\n    return abitype.formatAbiItem(abiConstructor);\n}\n/** @internal */\nexport function from(abiConstructor) {\n    return AbiItem.from(abiConstructor);\n}\n/** @internal */\nexport function fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new AbiItem.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAKO,SAAS,OAAO,GAAG,UAAU;IAChC,MAAM,CAAC,gBAAgB,QAAQ,GAAG,AAAC,CAAA;QAC/B,IAAI,MAAM,OAAO,CAAC,UAAU,CAAC,EAAE,GAAG;YAC9B,MAAM,CAAC,KAAK,QAAQ,GAAG;YACvB,OAAO;gBAAC,QAAQ;gBAAM;aAAQ;QAClC;QACA,OAAO;IACX,CAAA;IACA,MAAM,EAAE,QAAQ,EAAE,GAAG;IACrB,IAAI,eAAe,MAAM,CAAC,MAAM,KAAK,GACjC,OAAO;IACX,MAAM,OAAO,QAAQ,IAAI,CAAC,OAAO,CAAC,UAAU;IAC5C,OAAO,+KAAc,MAAM,CAAC,eAAe,MAAM,EAAE;AACvD;AAEO,SAAS,OAAO,GAAG,UAAU;IAChC,MAAM,CAAC,gBAAgB,QAAQ,GAAG,AAAC,CAAA;QAC/B,IAAI,MAAM,OAAO,CAAC,UAAU,CAAC,EAAE,GAAG;YAC9B,MAAM,CAAC,KAAK,QAAQ,GAAG;YACvB,OAAO;gBAAC,QAAQ;gBAAM;aAAQ;QAClC;QACA,OAAO;IACX,CAAA;IACA,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG;IAC3B,OAAO,qKAAI,MAAM,CAAC,UAAU,eAAe,MAAM,EAAE,UAAU,MAAM,SAC7D,+KAAc,MAAM,CAAC,eAAe,MAAM,EAAE,QAC5C;AACV;AAEO,SAAS,OAAO,cAAc;IACjC,OAAO,sMAAQ,aAAa,CAAC;AACjC;AAEO,SAAS,KAAK,cAAc;IAC/B,OAAO,yKAAQ,IAAI,CAAC;AACxB;AAEO,SAAS,QAAQ,GAAG;IACvB,MAAM,OAAO,IAAI,IAAI,CAAC,CAAC,OAAS,KAAK,IAAI,KAAK;IAC9C,IAAI,CAAC,MACD,MAAM,IAAI,yKAAQ,aAAa,CAAC;QAAE,MAAM;IAAc;IAC1D,OAAO;AACX,EACA,0CAA0C"}},
    {"offset": {"line": 7510, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}
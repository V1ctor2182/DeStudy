{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/regex.js"],"sourcesContent":["// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const isTupleRegex = /^\\(.+?\\).*?$/;\n//# sourceMappingURL=regex.js.map"],"names":[],"mappings":"AAAA,qGAAqG;AACrG,iEAAiE;;;;;;;AAC1D,SAAS,UAAU,KAAK,EAAE,MAAM;IACnC,MAAM,QAAQ,MAAM,IAAI,CAAC;IACzB,OAAO,OAAO;AAClB;AAGO,MAAM,aAAa;AAGnB,MAAM,eAAe;AACrB,MAAM,eAAe,gBAC5B,iCAAiC"}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 25, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js"],"sourcesContent":["import { execTyped } from '../regex.js';\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter(abiParameter) {\n    let type = abiParameter.type;\n    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n        type = '(';\n        const length = abiParameter.components.length;\n        for (let i = 0; i < length; i++) {\n            const component = abiParameter.components[i];\n            type += formatAbiParameter(component);\n            if (i < length - 1)\n                type += ', ';\n        }\n        const result = execTyped(tupleRegex, abiParameter.type);\n        type += `)${result?.array ?? ''}`;\n        return formatAbiParameter({\n            ...abiParameter,\n            type,\n        });\n    }\n    // Add `indexed` to type if in `abiParameter`\n    if ('indexed' in abiParameter && abiParameter.indexed)\n        type = `${type} indexed`;\n    // Return human-readable ABI parameter\n    if (abiParameter.name)\n        return `${type} ${abiParameter.name}`;\n    return type;\n}\n//# sourceMappingURL=formatAbiParameter.js.map"],"names":[],"mappings":";;;;;;AACA,2BAA2B;AAC3B,MAAM,aAAa;AAWZ,SAAS,mBAAmB,YAAY;IAC3C,IAAI,OAAO,aAAa,IAAI;IAC5B,IAAI,WAAW,IAAI,CAAC,aAAa,IAAI,KAAK,gBAAgB,cAAc;QACpE,OAAO;QACP,MAAM,SAAS,aAAa,UAAU,CAAC,MAAM;QAC7C,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,MAAM,YAAY,aAAa,UAAU,CAAC,EAAE;YAC5C,QAAQ,mBAAmB;YAC3B,IAAI,IAAI,SAAS,GACb,QAAQ;QAChB;QACA,MAAM,SAAS,gKAAU,YAAY,aAAa,IAAI;QACtD,QAAQ,CAAC,CAAC,EAAE,QAAQ,SAAS,GAAG,CAAC;QACjC,OAAO,mBAAmB;YACtB,GAAG,YAAY;YACf;QACJ;IACJ;IACA,6CAA6C;IAC7C,IAAI,aAAa,gBAAgB,aAAa,OAAO,EACjD,OAAO,CAAC,EAAE,KAAK,QAAQ,CAAC;IAC5B,sCAAsC;IACtC,IAAI,aAAa,IAAI,EACjB,OAAO,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa,IAAI,CAAC,CAAC;IACzC,OAAO;AACX,EACA,8CAA8C"}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js"],"sourcesContent":["import { formatAbiParameter, } from './formatAbiParameter.js';\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters(abiParameters) {\n    let params = '';\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        params += formatAbiParameter(abiParameter);\n        if (i !== length - 1)\n            params += ', ';\n    }\n    return params;\n}\n//# sourceMappingURL=formatAbiParameters.js.map"],"names":[],"mappings":";;;;;;AAcO,SAAS,oBAAoB,aAAa;IAC7C,IAAI,SAAS;IACb,MAAM,SAAS,cAAc,MAAM;IACnC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,MAAM,eAAe,aAAa,CAAC,EAAE;QACrC,UAAU,2MAAmB;QAC7B,IAAI,MAAM,SAAS,GACf,UAAU;IAClB;IACA,OAAO;AACX,EACA,+CAA+C"}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js"],"sourcesContent":["import { formatAbiParameters, } from './formatAbiParameters.js';\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem(abiItem) {\n    if (abiItem.type === 'function')\n        return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n            ? ` ${abiItem.stateMutability}`\n            : ''}${abiItem.outputs.length\n            ? ` returns (${formatAbiParameters(abiItem.outputs)})`\n            : ''}`;\n    if (abiItem.type === 'event')\n        return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'error')\n        return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'constructor')\n        return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    if (abiItem.type === 'fallback')\n        return 'fallback()';\n    return 'receive() external payable';\n}\n//# sourceMappingURL=formatAbiItem.js.map"],"names":[],"mappings":";;;;;;AAOO,SAAS,cAAc,OAAO;IACjC,IAAI,QAAQ,IAAI,KAAK,YACjB,OAAO,CAAC,SAAS,EAAE,QAAQ,IAAI,CAAC,CAAC,EAAE,6MAAoB,QAAQ,MAAM,EAAE,CAAC,EAAE,QAAQ,eAAe,IAAI,QAAQ,eAAe,KAAK,eAC3H,CAAC,CAAC,EAAE,QAAQ,eAAe,CAAC,CAAC,GAC7B,GAAG,EAAE,QAAQ,OAAO,CAAC,MAAM,GAC3B,CAAC,UAAU,EAAE,6MAAoB,QAAQ,OAAO,EAAE,CAAC,CAAC,GACpD,GAAG,CAAC;IACd,IAAI,QAAQ,IAAI,KAAK,SACjB,OAAO,CAAC,MAAM,EAAE,QAAQ,IAAI,CAAC,CAAC,EAAE,6MAAoB,QAAQ,MAAM,EAAE,CAAC,CAAC;IAC1E,IAAI,QAAQ,IAAI,KAAK,SACjB,OAAO,CAAC,MAAM,EAAE,QAAQ,IAAI,CAAC,CAAC,EAAE,6MAAoB,QAAQ,MAAM,EAAE,CAAC,CAAC;IAC1E,IAAI,QAAQ,IAAI,KAAK,eACjB,OAAO,CAAC,YAAY,EAAE,6MAAoB,QAAQ,MAAM,EAAE,CAAC,EAAE,QAAQ,eAAe,KAAK,YAAY,aAAa,GAAG,CAAC;IAC1H,IAAI,QAAQ,IAAI,KAAK,YACjB,OAAO;IACX,OAAO;AACX,EACA,yCAAyC"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/regex.js"],"sourcesContent":["// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const isTupleRegex = /^\\(.+?\\).*?$/;\n//# sourceMappingURL=regex.js.map"],"names":[],"mappings":"AAAA,qGAAqG;AACrG,iEAAiE;;;;;;;AAC1D,SAAS,UAAU,KAAK,EAAE,MAAM;IACnC,MAAM,QAAQ,MAAM,IAAI,CAAC;IACzB,OAAO,OAAO;AAClB;AAGO,MAAM,aAAa;AAGnB,MAAM,eAAe;AACrB,MAAM,eAAe,gBAC5B,iCAAiC"}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js"],"sourcesContent":["import { execTyped } from '../regex.js';\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter(abiParameter) {\n    let type = abiParameter.type;\n    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n        type = '(';\n        const length = abiParameter.components.length;\n        for (let i = 0; i < length; i++) {\n            const component = abiParameter.components[i];\n            type += formatAbiParameter(component);\n            if (i < length - 1)\n                type += ', ';\n        }\n        const result = execTyped(tupleRegex, abiParameter.type);\n        type += `)${result?.array ?? ''}`;\n        return formatAbiParameter({\n            ...abiParameter,\n            type,\n        });\n    }\n    // Add `indexed` to type if in `abiParameter`\n    if ('indexed' in abiParameter && abiParameter.indexed)\n        type = `${type} indexed`;\n    // Return human-readable ABI parameter\n    if (abiParameter.name)\n        return `${type} ${abiParameter.name}`;\n    return type;\n}\n//# sourceMappingURL=formatAbiParameter.js.map"],"names":[],"mappings":";;;;;;AACA,2BAA2B;AAC3B,MAAM,aAAa;AAWZ,SAAS,mBAAmB,YAAY;IAC3C,IAAI,OAAO,aAAa,IAAI;IAC5B,IAAI,WAAW,IAAI,CAAC,aAAa,IAAI,KAAK,gBAAgB,cAAc;QACpE,OAAO;QACP,MAAM,SAAS,aAAa,UAAU,CAAC,MAAM;QAC7C,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,MAAM,YAAY,aAAa,UAAU,CAAC,EAAE;YAC5C,QAAQ,mBAAmB;YAC3B,IAAI,IAAI,SAAS,GACb,QAAQ;QAChB;QACA,MAAM,SAAS,wLAAU,YAAY,aAAa,IAAI;QACtD,QAAQ,CAAC,CAAC,EAAE,QAAQ,SAAS,GAAG,CAAC;QACjC,OAAO,mBAAmB;YACtB,GAAG,YAAY;YACf;QACJ;IACJ;IACA,6CAA6C;IAC7C,IAAI,aAAa,gBAAgB,aAAa,OAAO,EACjD,OAAO,CAAC,EAAE,KAAK,QAAQ,CAAC;IAC5B,sCAAsC;IACtC,IAAI,aAAa,IAAI,EACjB,OAAO,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa,IAAI,CAAC,CAAC;IACzC,OAAO;AACX,EACA,8CAA8C"}},
    {"offset": {"line": 152, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js"],"sourcesContent":["import { formatAbiParameter, } from './formatAbiParameter.js';\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters(abiParameters) {\n    let params = '';\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        params += formatAbiParameter(abiParameter);\n        if (i !== length - 1)\n            params += ', ';\n    }\n    return params;\n}\n//# sourceMappingURL=formatAbiParameters.js.map"],"names":[],"mappings":";;;;;;AAcO,SAAS,oBAAoB,aAAa;IAC7C,IAAI,SAAS;IACb,MAAM,SAAS,cAAc,MAAM;IACnC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,MAAM,eAAe,aAAa,CAAC,EAAE;QACrC,UAAU,mOAAmB;QAC7B,IAAI,MAAM,SAAS,GACf,UAAU;IAClB;IACA,OAAO;AACX,EACA,+CAA+C"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js"],"sourcesContent":["import { formatAbiParameters, } from './formatAbiParameters.js';\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem(abiItem) {\n    if (abiItem.type === 'function')\n        return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n            ? ` ${abiItem.stateMutability}`\n            : ''}${abiItem.outputs?.length\n            ? ` returns (${formatAbiParameters(abiItem.outputs)})`\n            : ''}`;\n    if (abiItem.type === 'event')\n        return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'error')\n        return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'constructor')\n        return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    if (abiItem.type === 'fallback')\n        return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    return 'receive() external payable';\n}\n//# sourceMappingURL=formatAbiItem.js.map"],"names":[],"mappings":";;;;;;AAOO,SAAS,cAAc,OAAO;IACjC,IAAI,QAAQ,IAAI,KAAK,YACjB,OAAO,CAAC,SAAS,EAAE,QAAQ,IAAI,CAAC,CAAC,EAAE,qOAAoB,QAAQ,MAAM,EAAE,CAAC,EAAE,QAAQ,eAAe,IAAI,QAAQ,eAAe,KAAK,eAC3H,CAAC,CAAC,EAAE,QAAQ,eAAe,CAAC,CAAC,GAC7B,GAAG,EAAE,QAAQ,OAAO,EAAE,SACtB,CAAC,UAAU,EAAE,qOAAoB,QAAQ,OAAO,EAAE,CAAC,CAAC,GACpD,GAAG,CAAC;IACd,IAAI,QAAQ,IAAI,KAAK,SACjB,OAAO,CAAC,MAAM,EAAE,QAAQ,IAAI,CAAC,CAAC,EAAE,qOAAoB,QAAQ,MAAM,EAAE,CAAC,CAAC;IAC1E,IAAI,QAAQ,IAAI,KAAK,SACjB,OAAO,CAAC,MAAM,EAAE,QAAQ,IAAI,CAAC,CAAC,EAAE,qOAAoB,QAAQ,MAAM,EAAE,CAAC,CAAC;IAC1E,IAAI,QAAQ,IAAI,KAAK,eACjB,OAAO,CAAC,YAAY,EAAE,qOAAoB,QAAQ,MAAM,EAAE,CAAC,EAAE,QAAQ,eAAe,KAAK,YAAY,aAAa,GAAG,CAAC;IAC1H,IAAI,QAAQ,IAAI,KAAK,YACjB,OAAO,CAAC,mBAAmB,EAAE,QAAQ,eAAe,KAAK,YAAY,aAAa,GAAG,CAAC;IAC1F,OAAO;AACX,EACA,yCAAyC"}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js"],"sourcesContent":["import { execTyped } from '../../regex.js';\n// https://regexr.com/7gmok\nconst errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nexport function isErrorSignature(signature) {\n    return errorSignatureRegex.test(signature);\n}\nexport function execErrorSignature(signature) {\n    return execTyped(errorSignatureRegex, signature);\n}\n// https://regexr.com/7gmoq\nconst eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nexport function isEventSignature(signature) {\n    return eventSignatureRegex.test(signature);\n}\nexport function execEventSignature(signature) {\n    return execTyped(eventSignatureRegex, signature);\n}\n// https://regexr.com/7gmot\nconst functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/;\nexport function isFunctionSignature(signature) {\n    return functionSignatureRegex.test(signature);\n}\nexport function execFunctionSignature(signature) {\n    return execTyped(functionSignatureRegex, signature);\n}\n// https://regexr.com/7gmp3\nconst structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/;\nexport function isStructSignature(signature) {\n    return structSignatureRegex.test(signature);\n}\nexport function execStructSignature(signature) {\n    return execTyped(structSignatureRegex, signature);\n}\n// https://regexr.com/78u01\nconst constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nexport function isConstructorSignature(signature) {\n    return constructorSignatureRegex.test(signature);\n}\nexport function execConstructorSignature(signature) {\n    return execTyped(constructorSignatureRegex, signature);\n}\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex = /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/;\nexport function isFallbackSignature(signature) {\n    return fallbackSignatureRegex.test(signature);\n}\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/;\nexport function isReceiveSignature(signature) {\n    return receiveSignatureRegex.test(signature);\n}\nexport const modifiers = new Set([\n    'memory',\n    'indexed',\n    'storage',\n    'calldata',\n]);\nexport const eventModifiers = new Set(['indexed']);\nexport const functionModifiers = new Set([\n    'calldata',\n    'memory',\n    'storage',\n]);\n//# sourceMappingURL=signatures.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AACA,2BAA2B;AAC3B,MAAM,sBAAsB;AACrB,SAAS,iBAAiB,SAAS;IACtC,OAAO,oBAAoB,IAAI,CAAC;AACpC;AACO,SAAS,mBAAmB,SAAS;IACxC,OAAO,gKAAU,qBAAqB;AAC1C;AACA,2BAA2B;AAC3B,MAAM,sBAAsB;AACrB,SAAS,iBAAiB,SAAS;IACtC,OAAO,oBAAoB,IAAI,CAAC;AACpC;AACO,SAAS,mBAAmB,SAAS;IACxC,OAAO,gKAAU,qBAAqB;AAC1C;AACA,2BAA2B;AAC3B,MAAM,yBAAyB;AACxB,SAAS,oBAAoB,SAAS;IACzC,OAAO,uBAAuB,IAAI,CAAC;AACvC;AACO,SAAS,sBAAsB,SAAS;IAC3C,OAAO,gKAAU,wBAAwB;AAC7C;AACA,2BAA2B;AAC3B,MAAM,uBAAuB;AACtB,SAAS,kBAAkB,SAAS;IACvC,OAAO,qBAAqB,IAAI,CAAC;AACrC;AACO,SAAS,oBAAoB,SAAS;IACzC,OAAO,gKAAU,sBAAsB;AAC3C;AACA,2BAA2B;AAC3B,MAAM,4BAA4B;AAC3B,SAAS,uBAAuB,SAAS;IAC5C,OAAO,0BAA0B,IAAI,CAAC;AAC1C;AACO,SAAS,yBAAyB,SAAS;IAC9C,OAAO,gKAAU,2BAA2B;AAChD;AACA,2BAA2B;AAC3B,MAAM,yBAAyB;AACxB,SAAS,oBAAoB,SAAS;IACzC,OAAO,uBAAuB,IAAI,CAAC;AACvC;AACA,2BAA2B;AAC3B,MAAM,wBAAwB;AACvB,SAAS,mBAAmB,SAAS;IACxC,OAAO,sBAAsB,IAAI,CAAC;AACtC;AACO,MAAM,YAAY,IAAI,IAAI;IAC7B;IACA;IACA;IACA;CACH;AACM,MAAM,iBAAiB,IAAI,IAAI;IAAC;CAAU;AAC1C,MAAM,oBAAoB,IAAI,IAAI;IACrC;IACA;IACA;CACH,GACD,sCAAsC"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/runtime/cache.js"],"sourcesContent":["/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(param, type) {\n    if (type)\n        return `${type}:${param}`;\n    return param;\n}\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map([\n    // Unnamed\n    ['address', { type: 'address' }],\n    ['bool', { type: 'bool' }],\n    ['bytes', { type: 'bytes' }],\n    ['bytes32', { type: 'bytes32' }],\n    ['int', { type: 'int256' }],\n    ['int256', { type: 'int256' }],\n    ['string', { type: 'string' }],\n    ['uint', { type: 'uint256' }],\n    ['uint8', { type: 'uint8' }],\n    ['uint16', { type: 'uint16' }],\n    ['uint24', { type: 'uint24' }],\n    ['uint32', { type: 'uint32' }],\n    ['uint64', { type: 'uint64' }],\n    ['uint96', { type: 'uint96' }],\n    ['uint112', { type: 'uint112' }],\n    ['uint160', { type: 'uint160' }],\n    ['uint192', { type: 'uint192' }],\n    ['uint256', { type: 'uint256' }],\n    // Named\n    ['address owner', { type: 'address', name: 'owner' }],\n    ['address to', { type: 'address', name: 'to' }],\n    ['bool approved', { type: 'bool', name: 'approved' }],\n    ['bytes _data', { type: 'bytes', name: '_data' }],\n    ['bytes data', { type: 'bytes', name: 'data' }],\n    ['bytes signature', { type: 'bytes', name: 'signature' }],\n    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n    ['bytes32 r', { type: 'bytes32', name: 'r' }],\n    ['bytes32 root', { type: 'bytes32', name: 'root' }],\n    ['bytes32 s', { type: 'bytes32', name: 's' }],\n    ['string name', { type: 'string', name: 'name' }],\n    ['string symbol', { type: 'string', name: 'symbol' }],\n    ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint8 v', { type: 'uint8', name: 'v' }],\n    ['uint256 balance', { type: 'uint256', name: 'balance' }],\n    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint256 value', { type: 'uint256', name: 'value' }],\n    // Indexed\n    [\n        'event:address indexed from',\n        { type: 'address', name: 'from', indexed: true },\n    ],\n    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n    [\n        'event:uint indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n    [\n        'event:uint256 indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n]);\n//# sourceMappingURL=cache.js.map"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AACM,SAAS,qBAAqB,KAAK,EAAE,IAAI;IAC5C,IAAI,MACA,OAAO,CAAC,EAAE,KAAK,CAAC,EAAE,MAAM,CAAC;IAC7B,OAAO;AACX;AAMO,MAAM,iBAAiB,IAAI,IAAI;IAClC,UAAU;IACV;QAAC;QAAW;YAAE,MAAM;QAAU;KAAE;IAChC;QAAC;QAAQ;YAAE,MAAM;QAAO;KAAE;IAC1B;QAAC;QAAS;YAAE,MAAM;QAAQ;KAAE;IAC5B;QAAC;QAAW;YAAE,MAAM;QAAU;KAAE;IAChC;QAAC;QAAO;YAAE,MAAM;QAAS;KAAE;IAC3B;QAAC;QAAU;YAAE,MAAM;QAAS;KAAE;IAC9B;QAAC;QAAU;YAAE,MAAM;QAAS;KAAE;IAC9B;QAAC;QAAQ;YAAE,MAAM;QAAU;KAAE;IAC7B;QAAC;QAAS;YAAE,MAAM;QAAQ;KAAE;IAC5B;QAAC;QAAU;YAAE,MAAM;QAAS;KAAE;IAC9B;QAAC;QAAU;YAAE,MAAM;QAAS;KAAE;IAC9B;QAAC;QAAU;YAAE,MAAM;QAAS;KAAE;IAC9B;QAAC;QAAU;YAAE,MAAM;QAAS;KAAE;IAC9B;QAAC;QAAU;YAAE,MAAM;QAAS;KAAE;IAC9B;QAAC;QAAW;YAAE,MAAM;QAAU;KAAE;IAChC;QAAC;QAAW;YAAE,MAAM;QAAU;KAAE;IAChC;QAAC;QAAW;YAAE,MAAM;QAAU;KAAE;IAChC;QAAC;QAAW;YAAE,MAAM;QAAU;KAAE;IAChC,QAAQ;IACR;QAAC;QAAiB;YAAE,MAAM;YAAW,MAAM;QAAQ;KAAE;IACrD;QAAC;QAAc;YAAE,MAAM;YAAW,MAAM;QAAK;KAAE;IAC/C;QAAC;QAAiB;YAAE,MAAM;YAAQ,MAAM;QAAW;KAAE;IACrD;QAAC;QAAe;YAAE,MAAM;YAAS,MAAM;QAAQ;KAAE;IACjD;QAAC;QAAc;YAAE,MAAM;YAAS,MAAM;QAAO;KAAE;IAC/C;QAAC;QAAmB;YAAE,MAAM;YAAS,MAAM;QAAY;KAAE;IACzD;QAAC;QAAgB;YAAE,MAAM;YAAW,MAAM;QAAO;KAAE;IACnD;QAAC;QAAa;YAAE,MAAM;YAAW,MAAM;QAAI;KAAE;IAC7C;QAAC;QAAgB;YAAE,MAAM;YAAW,MAAM;QAAO;KAAE;IACnD;QAAC;QAAa;YAAE,MAAM;YAAW,MAAM;QAAI;KAAE;IAC7C;QAAC;QAAe;YAAE,MAAM;YAAU,MAAM;QAAO;KAAE;IACjD;QAAC;QAAiB;YAAE,MAAM;YAAU,MAAM;QAAS;KAAE;IACrD;QAAC;QAAmB;YAAE,MAAM;YAAU,MAAM;QAAW;KAAE;IACzD;QAAC;QAAgB;YAAE,MAAM;YAAW,MAAM;QAAU;KAAE;IACtD;QAAC;QAAW;YAAE,MAAM;YAAS,MAAM;QAAI;KAAE;IACzC;QAAC;QAAmB;YAAE,MAAM;YAAW,MAAM;QAAU;KAAE;IACzD;QAAC;QAAmB;YAAE,MAAM;YAAW,MAAM;QAAU;KAAE;IACzD;QAAC;QAAiB;YAAE,MAAM;YAAW,MAAM;QAAQ;KAAE;IACrD,UAAU;IACV;QACI;QACA;YAAE,MAAM;YAAW,MAAM;YAAQ,SAAS;QAAK;KAClD;IACD;QAAC;QAA4B;YAAE,MAAM;YAAW,MAAM;YAAM,SAAS;QAAK;KAAE;IAC5E;QACI;QACA;YAAE,MAAM;YAAW,MAAM;YAAW,SAAS;QAAK;KACrD;IACD;QACI;QACA;YAAE,MAAM;YAAW,MAAM;YAAW,SAAS;QAAK;KACrD;CACJ,GACD,iCAAiC"}},
    {"offset": {"line": 570, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 575, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/version.js"],"sourcesContent":["export const version = '1.0.6';\n//# sourceMappingURL=version.js.map"],"names":[],"mappings":";;;AAAO,MAAM,UAAU,SACvB,mCAAmC"}},
    {"offset": {"line": 579, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 584, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/errors.js"],"sourcesContent":["import { version } from './version.js';\nexport class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        const message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: abitype@${version}`,\n        ].join('\\n');\n        super(message);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiTypeError'\n        });\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n}\n//# sourceMappingURL=errors.js.map"],"names":[],"mappings":";;;;;;AACO,MAAM,kBAAkB;IAC3B,YAAY,YAAY,EAAE,OAAO,CAAC,CAAC,CAAE;QACjC,MAAM,UAAU,KAAK,KAAK,YAAY,YAChC,KAAK,KAAK,CAAC,OAAO,GAClB,KAAK,KAAK,EAAE,UACR,KAAK,KAAK,CAAC,OAAO,GAClB,KAAK,OAAO;QACtB,MAAM,WAAW,KAAK,KAAK,YAAY,YACjC,KAAK,KAAK,CAAC,QAAQ,IAAI,KAAK,QAAQ,GACpC,KAAK,QAAQ;QACnB,MAAM,UAAU;YACZ,gBAAgB;YAChB;eACI,KAAK,YAAY,GAAG;mBAAI,KAAK,YAAY;gBAAE;aAAG,GAAG,EAAE;eACnD,WAAW;gBAAC,CAAC,yBAAyB,EAAE,SAAS,CAAC;aAAC,GAAG,EAAE;eACxD,UAAU;gBAAC,CAAC,SAAS,EAAE,QAAQ,CAAC;aAAC,GAAG,EAAE;YAC1C,CAAC,iBAAiB,kKAAU,CAAC;SAChC,CAAC,IAAI,CAAC;QACP,KAAK,CAAC;QACN,OAAO,cAAc,CAAC,IAAI,EAAE,WAAW;YACnC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,YAAY;YACpC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB;YACxC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB;YACxC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;QACA,IAAI,KAAK,KAAK,EACV,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK;QAC3B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG,KAAK,YAAY;QACrC,IAAI,CAAC,YAAY,GAAG;IACxB;AACJ,EACA,kCAAkC"}},
    {"offset": {"line": 647, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 652, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class InvalidParenthesisError extends BaseError {\n    constructor({ current, depth }) {\n        super('Unbalanced parentheses.', {\n            metaMessages: [\n                `\"${current.trim()}\" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,\n            ],\n            details: `Depth \"${depth}\"`,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParenthesisError'\n        });\n    }\n}\n//# sourceMappingURL=splitParameters.js.map"],"names":[],"mappings":";;;;;;AACO,MAAM;IACT,YAAY,EAAE,OAAO,EAAE,KAAK,EAAE,CAAE;QAC5B,KAAK,CAAC,2BAA2B;YAC7B,cAAc;gBACV,CAAC,CAAC,EAAE,QAAQ,IAAI,GAAG,eAAe,EAAE,QAAQ,IAAI,YAAY,UAAU,aAAa,CAAC;aACvF;YACD,SAAS,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAC/B;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,2CAA2C"}},
    {"offset": {"line": 674, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 679, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/errors/signature.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class InvalidSignatureError extends BaseError {\n    constructor({ signature, type, }) {\n        super(`Invalid ${type} signature.`, {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidSignatureError'\n        });\n    }\n}\nexport class UnknownSignatureError extends BaseError {\n    constructor({ signature }) {\n        super('Unknown signature.', {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSignatureError'\n        });\n    }\n}\nexport class InvalidStructSignatureError extends BaseError {\n    constructor({ signature }) {\n        super('Invalid struct signature.', {\n            details: signature,\n            metaMessages: ['No properties exist.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidStructSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=signature.js.map"],"names":[],"mappings":";;;;;;;;AACO,MAAM;IACT,YAAY,EAAE,SAAS,EAAE,IAAI,EAAG,CAAE;QAC9B,KAAK,CAAC,CAAC,QAAQ,EAAE,KAAK,WAAW,CAAC,EAAE;YAChC,SAAS;QACb;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,SAAS,EAAE,CAAE;QACvB,KAAK,CAAC,sBAAsB;YACxB,SAAS;QACb;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,SAAS,EAAE,CAAE;QACvB,KAAK,CAAC,6BAA6B;YAC/B,SAAS;YACT,cAAc;gBAAC;aAAuB;QAC1C;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,qCAAqC"}},
    {"offset": {"line": 729, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 734, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class InvalidAbiParameterError extends BaseError {\n    constructor({ param }) {\n        super('Failed to parse ABI parameter.', {\n            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n            docsPath: '/api/human#parseabiparameter-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParameterError'\n        });\n    }\n}\nexport class InvalidAbiParametersError extends BaseError {\n    constructor({ params }) {\n        super('Failed to parse ABI parameters.', {\n            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n            docsPath: '/api/human#parseabiparameters-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParametersError'\n        });\n    }\n}\nexport class InvalidParameterError extends BaseError {\n    constructor({ param }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParameterError'\n        });\n    }\n}\nexport class SolidityProtectedKeywordError extends BaseError {\n    constructor({ param, name }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SolidityProtectedKeywordError'\n        });\n    }\n}\nexport class InvalidModifierError extends BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidModifierError'\n        });\n    }\n}\nexport class InvalidFunctionModifierError extends BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n                `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidFunctionModifierError'\n        });\n    }\n}\nexport class InvalidAbiTypeParameterError extends BaseError {\n    constructor({ abiParameter, }) {\n        super('Invalid ABI parameter.', {\n            details: JSON.stringify(abiParameter, null, 2),\n            metaMessages: ['ABI parameter type is invalid.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiTypeParameterError'\n        });\n    }\n}\n//# sourceMappingURL=abiParameter.js.map"],"names":[],"mappings":";;;;;;;;;;;;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,CAAE;QACnB,KAAK,CAAC,kCAAkC;YACpC,SAAS,CAAC,kBAAkB,EAAE,KAAK,SAAS,CAAC,OAAO,MAAM,GAAG,CAAC,CAAC;YAC/D,UAAU;QACd;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,MAAM,EAAE,CAAE;QACpB,KAAK,CAAC,mCAAmC;YACrC,SAAS,CAAC,mBAAmB,EAAE,KAAK,SAAS,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC;YACjE,UAAU;QACd;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,CAAE;QACnB,KAAK,CAAC,0BAA0B;YAC5B,SAAS;QACb;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,CAAE;QACzB,KAAK,CAAC,0BAA0B;YAC5B,SAAS;YACT,cAAc;gBACV,CAAC,CAAC,EAAE,KAAK,qGAAqG,CAAC;aAClH;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAG,CAAE;QACpC,KAAK,CAAC,0BAA0B;YAC5B,SAAS;YACT,cAAc;gBACV,CAAC,UAAU,EAAE,SAAS,aAAa,EAAE,OAAO,CAAC,KAAK,EAAE,KAAK,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;aAC3E;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAG,CAAE;QACpC,KAAK,CAAC,0BAA0B;YAC5B,SAAS;YACT,cAAc;gBACV,CAAC,UAAU,EAAE,SAAS,aAAa,EAAE,OAAO,CAAC,KAAK,EAAE,KAAK,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;gBACxE,CAAC,8EAA8E,EAAE,SAAS,YAAY,CAAC;aAC1G;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,YAAY,EAAG,CAAE;QAC3B,KAAK,CAAC,0BAA0B;YAC5B,SAAS,KAAK,SAAS,CAAC,cAAc,MAAM;YAC5C,cAAc;gBAAC;aAAiC;QACpD;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,wCAAwC"}},
    {"offset": {"line": 852, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 857, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class InvalidAbiItemError extends BaseError {\n    constructor({ signature }) {\n        super('Failed to parse ABI item.', {\n            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n            docsPath: '/api/human#parseabiitem-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiItemError'\n        });\n    }\n}\nexport class UnknownTypeError extends BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [\n                `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownTypeError'\n        });\n    }\n}\nexport class UnknownSolidityTypeError extends BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSolidityTypeError'\n        });\n    }\n}\n//# sourceMappingURL=abiItem.js.map"],"names":[],"mappings":";;;;;;;;AACO,MAAM;IACT,YAAY,EAAE,SAAS,EAAE,CAAE;QACvB,KAAK,CAAC,6BAA6B;YAC/B,SAAS,CAAC,aAAa,EAAE,KAAK,SAAS,CAAC,WAAW,MAAM,GAAG,CAAC,CAAC;YAC9D,UAAU;QACd;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,IAAI,EAAE,CAAE;QAClB,KAAK,CAAC,iBAAiB;YACnB,cAAc;gBACV,CAAC,MAAM,EAAE,KAAK,4EAA4E,CAAC;aAC9F;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,IAAI,EAAE,CAAE;QAClB,KAAK,CAAC,iBAAiB;YACnB,cAAc;gBAAC,CAAC,MAAM,EAAE,KAAK,0BAA0B,CAAC;aAAC;QAC7D;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,mCAAmC"}},
    {"offset": {"line": 909, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 914, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/runtime/utils.js"],"sourcesContent":["import { bytesRegex, execTyped, integerRegex, isTupleRegex, } from '../../regex.js';\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js';\nimport { InvalidFunctionModifierError, InvalidModifierError, InvalidParameterError, SolidityProtectedKeywordError, } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, UnknownSignatureError, } from '../errors/signature.js';\nimport { InvalidParenthesisError } from '../errors/splitParameters.js';\nimport { getParameterCacheKey, parameterCache } from './cache.js';\nimport { eventModifiers, execConstructorSignature, execErrorSignature, execEventSignature, execFunctionSignature, functionModifiers, isConstructorSignature, isErrorSignature, isEventSignature, isFallbackSignature, isFunctionSignature, isReceiveSignature, } from './signatures.js';\nexport function parseSignature(signature, structs = {}) {\n    if (isFunctionSignature(signature)) {\n        const match = execFunctionSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'function' });\n        const inputParams = splitParameters(match.parameters);\n        const inputs = [];\n        const inputLength = inputParams.length;\n        for (let i = 0; i < inputLength; i++) {\n            inputs.push(parseAbiParameter(inputParams[i], {\n                modifiers: functionModifiers,\n                structs,\n                type: 'function',\n            }));\n        }\n        const outputs = [];\n        if (match.returns) {\n            const outputParams = splitParameters(match.returns);\n            const outputLength = outputParams.length;\n            for (let i = 0; i < outputLength; i++) {\n                outputs.push(parseAbiParameter(outputParams[i], {\n                    modifiers: functionModifiers,\n                    structs,\n                    type: 'function',\n                }));\n            }\n        }\n        return {\n            name: match.name,\n            type: 'function',\n            stateMutability: match.stateMutability ?? 'nonpayable',\n            inputs,\n            outputs,\n        };\n    }\n    if (isEventSignature(signature)) {\n        const match = execEventSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'event' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], {\n                modifiers: eventModifiers,\n                structs,\n                type: 'event',\n            }));\n        }\n        return { name: match.name, type: 'event', inputs: abiParameters };\n    }\n    if (isErrorSignature(signature)) {\n        const match = execErrorSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'error' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));\n        }\n        return { name: match.name, type: 'error', inputs: abiParameters };\n    }\n    if (isConstructorSignature(signature)) {\n        const match = execConstructorSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'constructor' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));\n        }\n        return {\n            type: 'constructor',\n            stateMutability: match.stateMutability ?? 'nonpayable',\n            inputs: abiParameters,\n        };\n    }\n    if (isFallbackSignature(signature))\n        return { type: 'fallback' };\n    if (isReceiveSignature(signature))\n        return {\n            type: 'receive',\n            stateMutability: 'payable',\n        };\n    throw new UnknownSignatureError({ signature });\n}\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nexport function parseAbiParameter(param, options) {\n    // optional namespace cache by `type`\n    const parameterCacheKey = getParameterCacheKey(param, options?.type);\n    if (parameterCache.has(parameterCacheKey))\n        return parameterCache.get(parameterCacheKey);\n    const isTuple = isTupleRegex.test(param);\n    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n    if (!match)\n        throw new InvalidParameterError({ param });\n    if (match.name && isSolidityKeyword(match.name))\n        throw new SolidityProtectedKeywordError({ param, name: match.name });\n    const name = match.name ? { name: match.name } : {};\n    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};\n    const structs = options?.structs ?? {};\n    let type;\n    let components = {};\n    if (isTuple) {\n        type = 'tuple';\n        const params = splitParameters(match.type);\n        const components_ = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            // remove `modifiers` from `options` to prevent from being added to tuple components\n            components_.push(parseAbiParameter(params[i], { structs }));\n        }\n        components = { components: components_ };\n    }\n    else if (match.type in structs) {\n        type = 'tuple';\n        components = { components: structs[match.type] };\n    }\n    else if (dynamicIntegerRegex.test(match.type)) {\n        type = `${match.type}256`;\n    }\n    else {\n        type = match.type;\n        if (!(options?.type === 'struct') && !isSolidityType(type))\n            throw new UnknownSolidityTypeError({ type });\n    }\n    if (match.modifier) {\n        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n        if (!options?.modifiers?.has?.(match.modifier))\n            throw new InvalidModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n        // Check if resolved `type` is valid if there is a function modifier\n        if (functionModifiers.has(match.modifier) &&\n            !isValidDataLocation(type, !!match.array))\n            throw new InvalidFunctionModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n    }\n    const abiParameter = {\n        type: `${type}${match.array ?? ''}`,\n        ...name,\n        ...indexed,\n        ...components,\n    };\n    parameterCache.set(parameterCacheKey, abiParameter);\n    return abiParameter;\n}\n// s/o latika for this\nexport function splitParameters(params, result = [], current = '', depth = 0) {\n    const length = params.trim().length;\n    // biome-ignore lint/correctness/noUnreachable: recursive\n    for (let i = 0; i < length; i++) {\n        const char = params[i];\n        const tail = params.slice(i + 1);\n        switch (char) {\n            case ',':\n                return depth === 0\n                    ? splitParameters(tail, [...result, current.trim()])\n                    : splitParameters(tail, result, `${current}${char}`, depth);\n            case '(':\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\n            case ')':\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\n            default:\n                return splitParameters(tail, result, `${current}${char}`, depth);\n        }\n    }\n    if (current === '')\n        return result;\n    if (depth !== 0)\n        throw new InvalidParenthesisError({ current, depth });\n    result.push(current.trim());\n    return result;\n}\nexport function isSolidityType(type) {\n    return (type === 'address' ||\n        type === 'bool' ||\n        type === 'function' ||\n        type === 'string' ||\n        bytesRegex.test(type) ||\n        integerRegex.test(type));\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n/** @internal */\nexport function isSolidityKeyword(name) {\n    return (name === 'address' ||\n        name === 'bool' ||\n        name === 'function' ||\n        name === 'string' ||\n        name === 'tuple' ||\n        bytesRegex.test(name) ||\n        integerRegex.test(name) ||\n        protectedKeywordsRegex.test(name));\n}\n/** @internal */\nexport function isValidDataLocation(type, isArray) {\n    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\n//# sourceMappingURL=utils.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1162, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1167, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/errors/struct.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class CircularReferenceError extends BaseError {\n    constructor({ type }) {\n        super('Circular reference detected.', {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'CircularReferenceError'\n        });\n    }\n}\n//# sourceMappingURL=struct.js.map"],"names":[],"mappings":";;;;;;AACO,MAAM;IACT,YAAY,EAAE,IAAI,EAAE,CAAE;QAClB,KAAK,CAAC,gCAAgC;YAClC,cAAc;gBAAC,CAAC,QAAQ,EAAE,KAAK,0BAA0B,CAAC;aAAC;QAC/D;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,kCAAkC"}},
    {"offset": {"line": 1188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1193, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/runtime/structs.js"],"sourcesContent":["import { execTyped, isTupleRegex } from '../../regex.js';\nimport { UnknownTypeError } from '../errors/abiItem.js';\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, InvalidStructSignatureError, } from '../errors/signature.js';\nimport { CircularReferenceError } from '../errors/struct.js';\nimport { execStructSignature, isStructSignature } from './signatures.js';\nimport { isSolidityType, parseAbiParameter } from './utils.js';\nexport function parseStructs(signatures) {\n    // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n    const shallowStructs = {};\n    const signaturesLength = signatures.length;\n    for (let i = 0; i < signaturesLength; i++) {\n        const signature = signatures[i];\n        if (!isStructSignature(signature))\n            continue;\n        const match = execStructSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'struct' });\n        const properties = match.properties.split(';');\n        const components = [];\n        const propertiesLength = properties.length;\n        for (let k = 0; k < propertiesLength; k++) {\n            const property = properties[k];\n            const trimmed = property.trim();\n            if (!trimmed)\n                continue;\n            const abiParameter = parseAbiParameter(trimmed, {\n                type: 'struct',\n            });\n            components.push(abiParameter);\n        }\n        if (!components.length)\n            throw new InvalidStructSignatureError({ signature });\n        shallowStructs[match.name] = components;\n    }\n    // Resolve nested structs inside each parameter\n    const resolvedStructs = {};\n    const entries = Object.entries(shallowStructs);\n    const entriesLength = entries.length;\n    for (let i = 0; i < entriesLength; i++) {\n        const [name, parameters] = entries[i];\n        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n    }\n    return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = new Set()) {\n    const components = [];\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        const isTuple = isTupleRegex.test(abiParameter.type);\n        if (isTuple)\n            components.push(abiParameter);\n        else {\n            const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n            if (!match?.type)\n                throw new InvalidAbiTypeParameterError({ abiParameter });\n            const { array, type } = match;\n            if (type in structs) {\n                if (ancestors.has(type))\n                    throw new CircularReferenceError({ type });\n                components.push({\n                    ...abiParameter,\n                    type: `tuple${array ?? ''}`,\n                    components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type])),\n                });\n            }\n            else {\n                if (isSolidityType(type))\n                    components.push(abiParameter);\n                else\n                    throw new UnknownTypeError({ type });\n            }\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=structs.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAOO,SAAS,aAAa,UAAU;IACnC,0FAA0F;IAC1F,MAAM,iBAAiB,CAAC;IACxB,MAAM,mBAAmB,WAAW,MAAM;IAC1C,IAAK,IAAI,IAAI,GAAG,IAAI,kBAAkB,IAAK;QACvC,MAAM,YAAY,UAAU,CAAC,EAAE;QAC/B,IAAI,CAAC,6MAAkB,YACnB;QACJ,MAAM,QAAQ,+MAAoB;QAClC,IAAI,CAAC,OACD,MAAM,mNAA0B;YAAE;YAAW,MAAM;QAAS;QAChE,MAAM,aAAa,MAAM,UAAU,CAAC,KAAK,CAAC;QAC1C,MAAM,aAAa,EAAE;QACrB,MAAM,mBAAmB,WAAW,MAAM;QAC1C,IAAK,IAAI,IAAI,GAAG,IAAI,kBAAkB,IAAK;YACvC,MAAM,WAAW,UAAU,CAAC,EAAE;YAC9B,MAAM,UAAU,SAAS,IAAI;YAC7B,IAAI,CAAC,SACD;YACJ,MAAM,eAAe,wMAAkB,SAAS;gBAC5C,MAAM;YACV;YACA,WAAW,IAAI,CAAC;QACpB;QACA,IAAI,CAAC,WAAW,MAAM,EAClB,MAAM,yNAAgC;YAAE;QAAU;QACtD,cAAc,CAAC,MAAM,IAAI,CAAC,GAAG;IACjC;IACA,+CAA+C;IAC/C,MAAM,kBAAkB,CAAC;IACzB,MAAM,UAAU,OAAO,OAAO,CAAC;IAC/B,MAAM,gBAAgB,QAAQ,MAAM;IACpC,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,IAAK;QACpC,MAAM,CAAC,MAAM,WAAW,GAAG,OAAO,CAAC,EAAE;QACrC,eAAe,CAAC,KAAK,GAAG,eAAe,YAAY;IACvD;IACA,OAAO;AACX;AACA,MAAM,wBAAwB;AAC9B,SAAS,eAAe,aAAa,EAAE,OAAO,EAAE,YAAY,IAAI,KAAK;IACjE,MAAM,aAAa,EAAE;IACrB,MAAM,SAAS,cAAc,MAAM;IACnC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,MAAM,eAAe,aAAa,CAAC,EAAE;QACrC,MAAM,UAAU,mKAAa,IAAI,CAAC,aAAa,IAAI;QACnD,IAAI,SACA,WAAW,IAAI,CAAC;aACf;YACD,MAAM,QAAQ,gKAAU,uBAAuB,aAAa,IAAI;YAChE,IAAI,CAAC,OAAO,MACR,MAAM,6NAAiC;gBAAE;YAAa;YAC1D,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG;YACxB,IAAI,QAAQ,SAAS;gBACjB,IAAI,UAAU,GAAG,CAAC,OACd,MAAM,iNAA2B;oBAAE;gBAAK;gBAC5C,WAAW,IAAI,CAAC;oBACZ,GAAG,YAAY;oBACf,MAAM,CAAC,KAAK,EAAE,SAAS,GAAG,CAAC;oBAC3B,YAAY,eAAe,OAAO,CAAC,KAAK,IAAI,EAAE,EAAE,SAAS,IAAI,IAAI;2BAAI;wBAAW;qBAAK;gBACzF;YACJ,OACK;gBACD,IAAI,qMAAe,OACf,WAAW,IAAI,CAAC;qBAEhB,MAAM,4MAAqB;oBAAE;gBAAK;YAC1C;QACJ;IACJ;IACA,OAAO;AACX,EACA,mCAAmC"}},
    {"offset": {"line": 1286, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1291, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/parseAbi.js"],"sourcesContent":["import { isStructSignature } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseSignature } from './runtime/utils.js';\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-Readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * const abi = parseAbi([\n *   //  ^? const abi: readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   'function balanceOf(address owner) view returns (uint256)',\n *   'event Transfer(address indexed from, address indexed to, uint256 amount)',\n * ])\n */\nexport function parseAbi(signatures) {\n    const structs = parseStructs(signatures);\n    const abi = [];\n    const length = signatures.length;\n    for (let i = 0; i < length; i++) {\n        const signature = signatures[i];\n        if (isStructSignature(signature))\n            continue;\n        abi.push(parseSignature(signature, structs));\n    }\n    return abi;\n}\n//# sourceMappingURL=parseAbi.js.map"],"names":[],"mappings":";;;;;;;;;;AAgBO,SAAS,SAAS,UAAU;IAC/B,MAAM,UAAU,qMAAa;IAC7B,MAAM,MAAM,EAAE;IACd,MAAM,SAAS,WAAW,MAAM;IAChC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,MAAM,YAAY,UAAU,CAAC,EAAE;QAC/B,IAAI,6MAAkB,YAClB;QACJ,IAAI,IAAI,CAAC,qMAAe,WAAW;IACvC;IACA,OAAO;AACX,EACA,oCAAoC"}},
    {"offset": {"line": 1312, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1317, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js"],"sourcesContent":["import { execTyped } from '../../regex.js';\n// https://regexr.com/7gmok\nconst errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nexport function isErrorSignature(signature) {\n    return errorSignatureRegex.test(signature);\n}\nexport function execErrorSignature(signature) {\n    return execTyped(errorSignatureRegex, signature);\n}\n// https://regexr.com/7gmoq\nconst eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nexport function isEventSignature(signature) {\n    return eventSignatureRegex.test(signature);\n}\nexport function execEventSignature(signature) {\n    return execTyped(eventSignatureRegex, signature);\n}\n// https://regexr.com/7gmot\nconst functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/;\nexport function isFunctionSignature(signature) {\n    return functionSignatureRegex.test(signature);\n}\nexport function execFunctionSignature(signature) {\n    return execTyped(functionSignatureRegex, signature);\n}\n// https://regexr.com/7gmp3\nconst structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/;\nexport function isStructSignature(signature) {\n    return structSignatureRegex.test(signature);\n}\nexport function execStructSignature(signature) {\n    return execTyped(structSignatureRegex, signature);\n}\n// https://regexr.com/78u01\nconst constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nexport function isConstructorSignature(signature) {\n    return constructorSignatureRegex.test(signature);\n}\nexport function execConstructorSignature(signature) {\n    return execTyped(constructorSignatureRegex, signature);\n}\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex = /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/;\nexport function isFallbackSignature(signature) {\n    return fallbackSignatureRegex.test(signature);\n}\nexport function execFallbackSignature(signature) {\n    return execTyped(fallbackSignatureRegex, signature);\n}\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/;\nexport function isReceiveSignature(signature) {\n    return receiveSignatureRegex.test(signature);\n}\nexport const modifiers = new Set([\n    'memory',\n    'indexed',\n    'storage',\n    'calldata',\n]);\nexport const eventModifiers = new Set(['indexed']);\nexport const functionModifiers = new Set([\n    'calldata',\n    'memory',\n    'storage',\n]);\n//# sourceMappingURL=signatures.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA,2BAA2B;AAC3B,MAAM,sBAAsB;AACrB,SAAS,iBAAiB,SAAS;IACtC,OAAO,oBAAoB,IAAI,CAAC;AACpC;AACO,SAAS,mBAAmB,SAAS;IACxC,OAAO,wLAAU,qBAAqB;AAC1C;AACA,2BAA2B;AAC3B,MAAM,sBAAsB;AACrB,SAAS,iBAAiB,SAAS;IACtC,OAAO,oBAAoB,IAAI,CAAC;AACpC;AACO,SAAS,mBAAmB,SAAS;IACxC,OAAO,wLAAU,qBAAqB;AAC1C;AACA,2BAA2B;AAC3B,MAAM,yBAAyB;AACxB,SAAS,oBAAoB,SAAS;IACzC,OAAO,uBAAuB,IAAI,CAAC;AACvC;AACO,SAAS,sBAAsB,SAAS;IAC3C,OAAO,wLAAU,wBAAwB;AAC7C;AACA,2BAA2B;AAC3B,MAAM,uBAAuB;AACtB,SAAS,kBAAkB,SAAS;IACvC,OAAO,qBAAqB,IAAI,CAAC;AACrC;AACO,SAAS,oBAAoB,SAAS;IACzC,OAAO,wLAAU,sBAAsB;AAC3C;AACA,2BAA2B;AAC3B,MAAM,4BAA4B;AAC3B,SAAS,uBAAuB,SAAS;IAC5C,OAAO,0BAA0B,IAAI,CAAC;AAC1C;AACO,SAAS,yBAAyB,SAAS;IAC9C,OAAO,wLAAU,2BAA2B;AAChD;AACA,2BAA2B;AAC3B,MAAM,yBAAyB;AACxB,SAAS,oBAAoB,SAAS;IACzC,OAAO,uBAAuB,IAAI,CAAC;AACvC;AACO,SAAS,sBAAsB,SAAS;IAC3C,OAAO,wLAAU,wBAAwB;AAC7C;AACA,2BAA2B;AAC3B,MAAM,wBAAwB;AACvB,SAAS,mBAAmB,SAAS;IACxC,OAAO,sBAAsB,IAAI,CAAC;AACtC;AACO,MAAM,YAAY,IAAI,IAAI;IAC7B;IACA;IACA;IACA;CACH;AACM,MAAM,iBAAiB,IAAI,IAAI;IAAC;CAAU;AAC1C,MAAM,oBAAoB,IAAI,IAAI;IACrC;IACA;IACA;CACH,GACD,sCAAsC"}},
    {"offset": {"line": 1405, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1410, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/cache.js"],"sourcesContent":["/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(param, type, structs) {\n    let structKey = '';\n    if (structs)\n        for (const struct of Object.entries(structs)) {\n            if (!struct)\n                continue;\n            let propertyKey = '';\n            for (const property of struct[1]) {\n                propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;\n            }\n            structKey += `(${struct[0]}{${propertyKey}})`;\n        }\n    if (type)\n        return `${type}:${param}${structKey}`;\n    return param;\n}\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map([\n    // Unnamed\n    ['address', { type: 'address' }],\n    ['bool', { type: 'bool' }],\n    ['bytes', { type: 'bytes' }],\n    ['bytes32', { type: 'bytes32' }],\n    ['int', { type: 'int256' }],\n    ['int256', { type: 'int256' }],\n    ['string', { type: 'string' }],\n    ['uint', { type: 'uint256' }],\n    ['uint8', { type: 'uint8' }],\n    ['uint16', { type: 'uint16' }],\n    ['uint24', { type: 'uint24' }],\n    ['uint32', { type: 'uint32' }],\n    ['uint64', { type: 'uint64' }],\n    ['uint96', { type: 'uint96' }],\n    ['uint112', { type: 'uint112' }],\n    ['uint160', { type: 'uint160' }],\n    ['uint192', { type: 'uint192' }],\n    ['uint256', { type: 'uint256' }],\n    // Named\n    ['address owner', { type: 'address', name: 'owner' }],\n    ['address to', { type: 'address', name: 'to' }],\n    ['bool approved', { type: 'bool', name: 'approved' }],\n    ['bytes _data', { type: 'bytes', name: '_data' }],\n    ['bytes data', { type: 'bytes', name: 'data' }],\n    ['bytes signature', { type: 'bytes', name: 'signature' }],\n    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n    ['bytes32 r', { type: 'bytes32', name: 'r' }],\n    ['bytes32 root', { type: 'bytes32', name: 'root' }],\n    ['bytes32 s', { type: 'bytes32', name: 's' }],\n    ['string name', { type: 'string', name: 'name' }],\n    ['string symbol', { type: 'string', name: 'symbol' }],\n    ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint8 v', { type: 'uint8', name: 'v' }],\n    ['uint256 balance', { type: 'uint256', name: 'balance' }],\n    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint256 value', { type: 'uint256', name: 'value' }],\n    // Indexed\n    [\n        'event:address indexed from',\n        { type: 'address', name: 'from', indexed: true },\n    ],\n    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n    [\n        'event:uint indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n    [\n        'event:uint256 indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n]);\n//# sourceMappingURL=cache.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1703, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1708, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/version.js"],"sourcesContent":["export const version = '1.1.0';\n//# sourceMappingURL=version.js.map"],"names":[],"mappings":";;;AAAO,MAAM,UAAU,SACvB,mCAAmC"}},
    {"offset": {"line": 1712, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1717, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/errors.js"],"sourcesContent":["import { version } from './version.js';\nexport class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        const message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: abitype@${version}`,\n        ].join('\\n');\n        super(message);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiTypeError'\n        });\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n}\n//# sourceMappingURL=errors.js.map"],"names":[],"mappings":";;;;;;AACO,MAAM,kBAAkB;IAC3B,YAAY,YAAY,EAAE,OAAO,CAAC,CAAC,CAAE;QACjC,MAAM,UAAU,KAAK,KAAK,YAAY,YAChC,KAAK,KAAK,CAAC,OAAO,GAClB,KAAK,KAAK,EAAE,UACR,KAAK,KAAK,CAAC,OAAO,GAClB,KAAK,OAAO;QACtB,MAAM,WAAW,KAAK,KAAK,YAAY,YACjC,KAAK,KAAK,CAAC,QAAQ,IAAI,KAAK,QAAQ,GACpC,KAAK,QAAQ;QACnB,MAAM,UAAU;YACZ,gBAAgB;YAChB;eACI,KAAK,YAAY,GAAG;mBAAI,KAAK,YAAY;gBAAE;aAAG,GAAG,EAAE;eACnD,WAAW;gBAAC,CAAC,yBAAyB,EAAE,SAAS,CAAC;aAAC,GAAG,EAAE;eACxD,UAAU;gBAAC,CAAC,SAAS,EAAE,QAAQ,CAAC;aAAC,GAAG,EAAE;YAC1C,CAAC,iBAAiB,0LAAU,CAAC;SAChC,CAAC,IAAI,CAAC;QACP,KAAK,CAAC;QACN,OAAO,cAAc,CAAC,IAAI,EAAE,WAAW;YACnC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,YAAY;YACpC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB;YACxC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB;YACxC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;QACA,IAAI,KAAK,KAAK,EACV,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK;QAC3B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG,KAAK,YAAY;QACrC,IAAI,CAAC,YAAY,GAAG;IACxB;AACJ,EACA,kCAAkC"}},
    {"offset": {"line": 1780, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1785, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class InvalidParenthesisError extends BaseError {\n    constructor({ current, depth }) {\n        super('Unbalanced parentheses.', {\n            metaMessages: [\n                `\"${current.trim()}\" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,\n            ],\n            details: `Depth \"${depth}\"`,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParenthesisError'\n        });\n    }\n}\n//# sourceMappingURL=splitParameters.js.map"],"names":[],"mappings":";;;;;;AACO,MAAM;IACT,YAAY,EAAE,OAAO,EAAE,KAAK,EAAE,CAAE;QAC5B,KAAK,CAAC,2BAA2B;YAC7B,cAAc;gBACV,CAAC,CAAC,EAAE,QAAQ,IAAI,GAAG,eAAe,EAAE,QAAQ,IAAI,YAAY,UAAU,aAAa,CAAC;aACvF;YACD,SAAS,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAC/B;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,2CAA2C"}},
    {"offset": {"line": 1807, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1812, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/signature.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class InvalidSignatureError extends BaseError {\n    constructor({ signature, type, }) {\n        super(`Invalid ${type} signature.`, {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidSignatureError'\n        });\n    }\n}\nexport class UnknownSignatureError extends BaseError {\n    constructor({ signature }) {\n        super('Unknown signature.', {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSignatureError'\n        });\n    }\n}\nexport class InvalidStructSignatureError extends BaseError {\n    constructor({ signature }) {\n        super('Invalid struct signature.', {\n            details: signature,\n            metaMessages: ['No properties exist.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidStructSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=signature.js.map"],"names":[],"mappings":";;;;;;;;AACO,MAAM;IACT,YAAY,EAAE,SAAS,EAAE,IAAI,EAAG,CAAE;QAC9B,KAAK,CAAC,CAAC,QAAQ,EAAE,KAAK,WAAW,CAAC,EAAE;YAChC,SAAS;QACb;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,SAAS,EAAE,CAAE;QACvB,KAAK,CAAC,sBAAsB;YACxB,SAAS;QACb;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,SAAS,EAAE,CAAE;QACvB,KAAK,CAAC,6BAA6B;YAC/B,SAAS;YACT,cAAc;gBAAC;aAAuB;QAC1C;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,qCAAqC"}},
    {"offset": {"line": 1862, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1867, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class InvalidAbiParameterError extends BaseError {\n    constructor({ param }) {\n        super('Failed to parse ABI parameter.', {\n            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n            docsPath: '/api/human#parseabiparameter-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParameterError'\n        });\n    }\n}\nexport class InvalidAbiParametersError extends BaseError {\n    constructor({ params }) {\n        super('Failed to parse ABI parameters.', {\n            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n            docsPath: '/api/human#parseabiparameters-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParametersError'\n        });\n    }\n}\nexport class InvalidParameterError extends BaseError {\n    constructor({ param }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParameterError'\n        });\n    }\n}\nexport class SolidityProtectedKeywordError extends BaseError {\n    constructor({ param, name }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SolidityProtectedKeywordError'\n        });\n    }\n}\nexport class InvalidModifierError extends BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidModifierError'\n        });\n    }\n}\nexport class InvalidFunctionModifierError extends BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n                `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidFunctionModifierError'\n        });\n    }\n}\nexport class InvalidAbiTypeParameterError extends BaseError {\n    constructor({ abiParameter, }) {\n        super('Invalid ABI parameter.', {\n            details: JSON.stringify(abiParameter, null, 2),\n            metaMessages: ['ABI parameter type is invalid.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiTypeParameterError'\n        });\n    }\n}\n//# sourceMappingURL=abiParameter.js.map"],"names":[],"mappings":";;;;;;;;;;;;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,CAAE;QACnB,KAAK,CAAC,kCAAkC;YACpC,SAAS,CAAC,kBAAkB,EAAE,KAAK,SAAS,CAAC,OAAO,MAAM,GAAG,CAAC,CAAC;YAC/D,UAAU;QACd;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,MAAM,EAAE,CAAE;QACpB,KAAK,CAAC,mCAAmC;YACrC,SAAS,CAAC,mBAAmB,EAAE,KAAK,SAAS,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC;YACjE,UAAU;QACd;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,CAAE;QACnB,KAAK,CAAC,0BAA0B;YAC5B,SAAS;QACb;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,CAAE;QACzB,KAAK,CAAC,0BAA0B;YAC5B,SAAS;YACT,cAAc;gBACV,CAAC,CAAC,EAAE,KAAK,qGAAqG,CAAC;aAClH;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAG,CAAE;QACpC,KAAK,CAAC,0BAA0B;YAC5B,SAAS;YACT,cAAc;gBACV,CAAC,UAAU,EAAE,SAAS,aAAa,EAAE,OAAO,CAAC,KAAK,EAAE,KAAK,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;aAC3E;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAG,CAAE;QACpC,KAAK,CAAC,0BAA0B;YAC5B,SAAS;YACT,cAAc;gBACV,CAAC,UAAU,EAAE,SAAS,aAAa,EAAE,OAAO,CAAC,KAAK,EAAE,KAAK,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;gBACxE,CAAC,8EAA8E,EAAE,SAAS,YAAY,CAAC;aAC1G;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,YAAY,EAAG,CAAE;QAC3B,KAAK,CAAC,0BAA0B;YAC5B,SAAS,KAAK,SAAS,CAAC,cAAc,MAAM;YAC5C,cAAc;gBAAC;aAAiC;QACpD;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,wCAAwC"}},
    {"offset": {"line": 1985, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1990, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class InvalidAbiItemError extends BaseError {\n    constructor({ signature }) {\n        super('Failed to parse ABI item.', {\n            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n            docsPath: '/api/human#parseabiitem-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiItemError'\n        });\n    }\n}\nexport class UnknownTypeError extends BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [\n                `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownTypeError'\n        });\n    }\n}\nexport class UnknownSolidityTypeError extends BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSolidityTypeError'\n        });\n    }\n}\n//# sourceMappingURL=abiItem.js.map"],"names":[],"mappings":";;;;;;;;AACO,MAAM;IACT,YAAY,EAAE,SAAS,EAAE,CAAE;QACvB,KAAK,CAAC,6BAA6B;YAC/B,SAAS,CAAC,aAAa,EAAE,KAAK,SAAS,CAAC,WAAW,MAAM,GAAG,CAAC,CAAC;YAC9D,UAAU;QACd;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,IAAI,EAAE,CAAE;QAClB,KAAK,CAAC,iBAAiB;YACnB,cAAc;gBACV,CAAC,MAAM,EAAE,KAAK,4EAA4E,CAAC;aAC9F;QACL;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ;AACO,MAAM;IACT,YAAY,EAAE,IAAI,EAAE,CAAE;QAClB,KAAK,CAAC,iBAAiB;YACnB,cAAc;gBAAC,CAAC,MAAM,EAAE,KAAK,0BAA0B,CAAC;aAAC;QAC7D;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,mCAAmC"}},
    {"offset": {"line": 2042, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2047, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/utils.js"],"sourcesContent":["import { bytesRegex, execTyped, integerRegex, isTupleRegex, } from '../../regex.js';\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js';\nimport { InvalidFunctionModifierError, InvalidModifierError, InvalidParameterError, SolidityProtectedKeywordError, } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, UnknownSignatureError, } from '../errors/signature.js';\nimport { InvalidParenthesisError } from '../errors/splitParameters.js';\nimport { getParameterCacheKey, parameterCache } from './cache.js';\nimport { eventModifiers, execConstructorSignature, execErrorSignature, execEventSignature, execFallbackSignature, execFunctionSignature, functionModifiers, isConstructorSignature, isErrorSignature, isEventSignature, isFallbackSignature, isFunctionSignature, isReceiveSignature, } from './signatures.js';\nexport function parseSignature(signature, structs = {}) {\n    if (isFunctionSignature(signature))\n        return parseFunctionSignature(signature, structs);\n    if (isEventSignature(signature))\n        return parseEventSignature(signature, structs);\n    if (isErrorSignature(signature))\n        return parseErrorSignature(signature, structs);\n    if (isConstructorSignature(signature))\n        return parseConstructorSignature(signature, structs);\n    if (isFallbackSignature(signature))\n        return parseFallbackSignature(signature);\n    if (isReceiveSignature(signature))\n        return {\n            type: 'receive',\n            stateMutability: 'payable',\n        };\n    throw new UnknownSignatureError({ signature });\n}\nexport function parseFunctionSignature(signature, structs = {}) {\n    const match = execFunctionSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'function' });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n        inputs.push(parseAbiParameter(inputParams[i], {\n            modifiers: functionModifiers,\n            structs,\n            type: 'function',\n        }));\n    }\n    const outputs = [];\n    if (match.returns) {\n        const outputParams = splitParameters(match.returns);\n        const outputLength = outputParams.length;\n        for (let i = 0; i < outputLength; i++) {\n            outputs.push(parseAbiParameter(outputParams[i], {\n                modifiers: functionModifiers,\n                structs,\n                type: 'function',\n            }));\n        }\n    }\n    return {\n        name: match.name,\n        type: 'function',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n        inputs,\n        outputs,\n    };\n}\nexport function parseEventSignature(signature, structs = {}) {\n    const match = execEventSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'event' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], {\n            modifiers: eventModifiers,\n            structs,\n            type: 'event',\n        }));\n    return { name: match.name, type: 'event', inputs: abiParameters };\n}\nexport function parseErrorSignature(signature, structs = {}) {\n    const match = execErrorSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'error' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));\n    return { name: match.name, type: 'error', inputs: abiParameters };\n}\nexport function parseConstructorSignature(signature, structs = {}) {\n    const match = execConstructorSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'constructor' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));\n    return {\n        type: 'constructor',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n        inputs: abiParameters,\n    };\n}\nexport function parseFallbackSignature(signature) {\n    const match = execFallbackSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'fallback' });\n    return {\n        type: 'fallback',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n    };\n}\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\\spayable)?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nexport function parseAbiParameter(param, options) {\n    // optional namespace cache by `type`\n    const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);\n    if (parameterCache.has(parameterCacheKey))\n        return parameterCache.get(parameterCacheKey);\n    const isTuple = isTupleRegex.test(param);\n    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n    if (!match)\n        throw new InvalidParameterError({ param });\n    if (match.name && isSolidityKeyword(match.name))\n        throw new SolidityProtectedKeywordError({ param, name: match.name });\n    const name = match.name ? { name: match.name } : {};\n    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};\n    const structs = options?.structs ?? {};\n    let type;\n    let components = {};\n    if (isTuple) {\n        type = 'tuple';\n        const params = splitParameters(match.type);\n        const components_ = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            // remove `modifiers` from `options` to prevent from being added to tuple components\n            components_.push(parseAbiParameter(params[i], { structs }));\n        }\n        components = { components: components_ };\n    }\n    else if (match.type in structs) {\n        type = 'tuple';\n        components = { components: structs[match.type] };\n    }\n    else if (dynamicIntegerRegex.test(match.type)) {\n        type = `${match.type}256`;\n    }\n    else if (match.type === 'address payable') {\n        type = 'address';\n    }\n    else {\n        type = match.type;\n        if (!(options?.type === 'struct') && !isSolidityType(type))\n            throw new UnknownSolidityTypeError({ type });\n    }\n    if (match.modifier) {\n        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n        if (!options?.modifiers?.has?.(match.modifier))\n            throw new InvalidModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n        // Check if resolved `type` is valid if there is a function modifier\n        if (functionModifiers.has(match.modifier) &&\n            !isValidDataLocation(type, !!match.array))\n            throw new InvalidFunctionModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n    }\n    const abiParameter = {\n        type: `${type}${match.array ?? ''}`,\n        ...name,\n        ...indexed,\n        ...components,\n    };\n    parameterCache.set(parameterCacheKey, abiParameter);\n    return abiParameter;\n}\n// s/o latika for this\nexport function splitParameters(params, result = [], current = '', depth = 0) {\n    const length = params.trim().length;\n    // biome-ignore lint/correctness/noUnreachable: recursive\n    for (let i = 0; i < length; i++) {\n        const char = params[i];\n        const tail = params.slice(i + 1);\n        switch (char) {\n            case ',':\n                return depth === 0\n                    ? splitParameters(tail, [...result, current.trim()])\n                    : splitParameters(tail, result, `${current}${char}`, depth);\n            case '(':\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\n            case ')':\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\n            default:\n                return splitParameters(tail, result, `${current}${char}`, depth);\n        }\n    }\n    if (current === '')\n        return result;\n    if (depth !== 0)\n        throw new InvalidParenthesisError({ current, depth });\n    result.push(current.trim());\n    return result;\n}\nexport function isSolidityType(type) {\n    return (type === 'address' ||\n        type === 'bool' ||\n        type === 'function' ||\n        type === 'string' ||\n        bytesRegex.test(type) ||\n        integerRegex.test(type));\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n/** @internal */\nexport function isSolidityKeyword(name) {\n    return (name === 'address' ||\n        name === 'bool' ||\n        name === 'function' ||\n        name === 'string' ||\n        name === 'tuple' ||\n        bytesRegex.test(name) ||\n        integerRegex.test(name) ||\n        protectedKeywordsRegex.test(name));\n}\n/** @internal */\nexport function isValidDataLocation(type, isArray) {\n    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\n//# sourceMappingURL=utils.js.map"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2309, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2314, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/struct.js"],"sourcesContent":["import { BaseError } from '../../errors.js';\nexport class CircularReferenceError extends BaseError {\n    constructor({ type }) {\n        super('Circular reference detected.', {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'CircularReferenceError'\n        });\n    }\n}\n//# sourceMappingURL=struct.js.map"],"names":[],"mappings":";;;;;;AACO,MAAM;IACT,YAAY,EAAE,IAAI,EAAE,CAAE;QAClB,KAAK,CAAC,gCAAgC;YAClC,cAAc;gBAAC,CAAC,QAAQ,EAAE,KAAK,0BAA0B,CAAC;aAAC;QAC/D;QACA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ;YAChC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO;QACX;IACJ;AACJ,EACA,kCAAkC"}},
    {"offset": {"line": 2335, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2340, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/structs.js"],"sourcesContent":["import { execTyped, isTupleRegex } from '../../regex.js';\nimport { UnknownTypeError } from '../errors/abiItem.js';\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, InvalidStructSignatureError, } from '../errors/signature.js';\nimport { CircularReferenceError } from '../errors/struct.js';\nimport { execStructSignature, isStructSignature } from './signatures.js';\nimport { isSolidityType, parseAbiParameter } from './utils.js';\nexport function parseStructs(signatures) {\n    // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n    const shallowStructs = {};\n    const signaturesLength = signatures.length;\n    for (let i = 0; i < signaturesLength; i++) {\n        const signature = signatures[i];\n        if (!isStructSignature(signature))\n            continue;\n        const match = execStructSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'struct' });\n        const properties = match.properties.split(';');\n        const components = [];\n        const propertiesLength = properties.length;\n        for (let k = 0; k < propertiesLength; k++) {\n            const property = properties[k];\n            const trimmed = property.trim();\n            if (!trimmed)\n                continue;\n            const abiParameter = parseAbiParameter(trimmed, {\n                type: 'struct',\n            });\n            components.push(abiParameter);\n        }\n        if (!components.length)\n            throw new InvalidStructSignatureError({ signature });\n        shallowStructs[match.name] = components;\n    }\n    // Resolve nested structs inside each parameter\n    const resolvedStructs = {};\n    const entries = Object.entries(shallowStructs);\n    const entriesLength = entries.length;\n    for (let i = 0; i < entriesLength; i++) {\n        const [name, parameters] = entries[i];\n        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n    }\n    return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = new Set()) {\n    const components = [];\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        const isTuple = isTupleRegex.test(abiParameter.type);\n        if (isTuple)\n            components.push(abiParameter);\n        else {\n            const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n            if (!match?.type)\n                throw new InvalidAbiTypeParameterError({ abiParameter });\n            const { array, type } = match;\n            if (type in structs) {\n                if (ancestors.has(type))\n                    throw new CircularReferenceError({ type });\n                components.push({\n                    ...abiParameter,\n                    type: `tuple${array ?? ''}`,\n                    components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type])),\n                });\n            }\n            else {\n                if (isSolidityType(type))\n                    components.push(abiParameter);\n                else\n                    throw new UnknownTypeError({ type });\n            }\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=structs.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAOO,SAAS,aAAa,UAAU;IACnC,0FAA0F;IAC1F,MAAM,iBAAiB,CAAC;IACxB,MAAM,mBAAmB,WAAW,MAAM;IAC1C,IAAK,IAAI,IAAI,GAAG,IAAI,kBAAkB,IAAK;QACvC,MAAM,YAAY,UAAU,CAAC,EAAE;QAC/B,IAAI,CAAC,qOAAkB,YACnB;QACJ,MAAM,QAAQ,uOAAoB;QAClC,IAAI,CAAC,OACD,MAAM,2OAA0B;YAAE;YAAW,MAAM;QAAS;QAChE,MAAM,aAAa,MAAM,UAAU,CAAC,KAAK,CAAC;QAC1C,MAAM,aAAa,EAAE;QACrB,MAAM,mBAAmB,WAAW,MAAM;QAC1C,IAAK,IAAI,IAAI,GAAG,IAAI,kBAAkB,IAAK;YACvC,MAAM,WAAW,UAAU,CAAC,EAAE;YAC9B,MAAM,UAAU,SAAS,IAAI;YAC7B,IAAI,CAAC,SACD;YACJ,MAAM,eAAe,gOAAkB,SAAS;gBAC5C,MAAM;YACV;YACA,WAAW,IAAI,CAAC;QACpB;QACA,IAAI,CAAC,WAAW,MAAM,EAClB,MAAM,iPAAgC;YAAE;QAAU;QACtD,cAAc,CAAC,MAAM,IAAI,CAAC,GAAG;IACjC;IACA,+CAA+C;IAC/C,MAAM,kBAAkB,CAAC;IACzB,MAAM,UAAU,OAAO,OAAO,CAAC;IAC/B,MAAM,gBAAgB,QAAQ,MAAM;IACpC,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,IAAK;QACpC,MAAM,CAAC,MAAM,WAAW,GAAG,OAAO,CAAC,EAAE;QACrC,eAAe,CAAC,KAAK,GAAG,eAAe,YAAY;IACvD;IACA,OAAO;AACX;AACA,MAAM,wBAAwB;AAC9B,SAAS,eAAe,aAAa,EAAE,OAAO,EAAE,YAAY,IAAI,KAAK;IACjE,MAAM,aAAa,EAAE;IACrB,MAAM,SAAS,cAAc,MAAM;IACnC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,MAAM,eAAe,aAAa,CAAC,EAAE;QACrC,MAAM,UAAU,2LAAa,IAAI,CAAC,aAAa,IAAI;QACnD,IAAI,SACA,WAAW,IAAI,CAAC;aACf;YACD,MAAM,QAAQ,wLAAU,uBAAuB,aAAa,IAAI;YAChE,IAAI,CAAC,OAAO,MACR,MAAM,qPAAiC;gBAAE;YAAa;YAC1D,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG;YACxB,IAAI,QAAQ,SAAS;gBACjB,IAAI,UAAU,GAAG,CAAC,OACd,MAAM,yOAA2B;oBAAE;gBAAK;gBAC5C,WAAW,IAAI,CAAC;oBACZ,GAAG,YAAY;oBACf,MAAM,CAAC,KAAK,EAAE,SAAS,GAAG,CAAC;oBAC3B,YAAY,eAAe,OAAO,CAAC,KAAK,IAAI,EAAE,EAAE,SAAS,IAAI,IAAI;2BAAI;wBAAW;qBAAK;gBACzF;YACJ,OACK;gBACD,IAAI,6NAAe,OACf,WAAW,IAAI,CAAC;qBAEhB,MAAM,oOAAqB;oBAAE;gBAAK;YAC1C;QACJ;IACJ;IACA,OAAO;AACX,EACA,mCAAmC"}},
    {"offset": {"line": 2433, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2438, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js"],"sourcesContent":["import { isStructSignature } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseSignature } from './runtime/utils.js';\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-Readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * const abi = parseAbi([\n *   //  ^? const abi: readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   'function balanceOf(address owner) view returns (uint256)',\n *   'event Transfer(address indexed from, address indexed to, uint256 amount)',\n * ])\n */\nexport function parseAbi(signatures) {\n    const structs = parseStructs(signatures);\n    const abi = [];\n    const length = signatures.length;\n    for (let i = 0; i < length; i++) {\n        const signature = signatures[i];\n        if (isStructSignature(signature))\n            continue;\n        abi.push(parseSignature(signature, structs));\n    }\n    return abi;\n}\n//# sourceMappingURL=parseAbi.js.map"],"names":[],"mappings":";;;;;;;;;;AAgBO,SAAS,SAAS,UAAU;IAC/B,MAAM,UAAU,6NAAa;IAC7B,MAAM,MAAM,EAAE;IACd,MAAM,SAAS,WAAW,MAAM;IAChC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,MAAM,YAAY,UAAU,CAAC,EAAE;QAC/B,IAAI,qOAAkB,YAClB;QACJ,IAAI,IAAI,CAAC,6NAAe,WAAW;IACvC;IACA,OAAO;AACX,EACA,oCAAoC"}},
    {"offset": {"line": 2459, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2464, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/exports/index.js"],"sourcesContent":["// biome-ignore lint/performance/noBarrelFile: <explanation>\nexport { BaseError } from '../errors.js';\nexport { narrow } from '../narrow.js';\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Human-Readable\nexport { formatAbi, } from '../human-readable/formatAbi.js';\nexport { formatAbiItem, } from '../human-readable/formatAbiItem.js';\nexport { formatAbiParameter, } from '../human-readable/formatAbiParameter.js';\nexport { formatAbiParameters, } from '../human-readable/formatAbiParameters.js';\nexport { parseAbi } from '../human-readable/parseAbi.js';\nexport { parseAbiItem, } from '../human-readable/parseAbiItem.js';\nexport { parseAbiParameter, } from '../human-readable/parseAbiParameter.js';\nexport { parseAbiParameters, } from '../human-readable/parseAbiParameters.js';\nexport { UnknownTypeError, InvalidAbiItemError, UnknownSolidityTypeError, } from '../human-readable/errors/abiItem.js';\nexport { InvalidAbiTypeParameterError, InvalidFunctionModifierError, InvalidModifierError, SolidityProtectedKeywordError, InvalidParameterError, InvalidAbiParametersError, InvalidAbiParameterError, } from '../human-readable/errors/abiParameter.js';\nexport { InvalidStructSignatureError, InvalidSignatureError, UnknownSignatureError, } from '../human-readable/errors/signature.js';\nexport { InvalidParenthesisError } from '../human-readable/errors/splitParameters.js';\nexport { CircularReferenceError } from '../human-readable/errors/struct.js';\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"AAAA,4DAA4D;;;;;;;;;;;;;;;;;CAkB5D,iCAAiC"}},
    {"offset": {"line": 2482, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2487, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js"],"sourcesContent":["import { InvalidAbiParametersError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { splitParameters } from './runtime/utils.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters(params) {\n    const abiParameters = [];\n    if (typeof params === 'string') {\n        const parameters = splitParameters(params);\n        const length = parameters.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter_(parameters[i], { modifiers }));\n        }\n    }\n    else {\n        const structs = parseStructs(params);\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            const signature = params[i];\n            if (isStructSignature(signature))\n                continue;\n            const parameters = splitParameters(signature);\n            const length = parameters.length;\n            for (let k = 0; k < length; k++) {\n                abiParameters.push(parseAbiParameter_(parameters[k], { modifiers, structs }));\n            }\n        }\n    }\n    if (abiParameters.length === 0)\n        throw new InvalidAbiParametersError({ params });\n    return abiParameters;\n}\n//# sourceMappingURL=parseAbiParameters.js.map"],"names":[],"mappings":";;;;;;;;;;;;;AAsBO,SAAS,mBAAmB,MAAM;IACrC,MAAM,gBAAgB,EAAE;IACxB,IAAI,OAAO,WAAW,UAAU;QAC5B,MAAM,aAAa,sMAAgB;QACnC,MAAM,SAAS,WAAW,MAAM;QAChC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,cAAc,IAAI,CAAC,wMAAmB,UAAU,CAAC,EAAE,EAAE;gBAAE,SAAS;YAAC;QACrE;IACJ,OACK;QACD,MAAM,UAAU,qMAAa;QAC7B,MAAM,SAAS,OAAO,MAAM;QAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,MAAM,YAAY,MAAM,CAAC,EAAE;YAC3B,IAAI,6MAAkB,YAClB;YACJ,MAAM,aAAa,sMAAgB;YACnC,MAAM,SAAS,WAAW,MAAM;YAChC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;gBAC7B,cAAc,IAAI,CAAC,wMAAmB,UAAU,CAAC,EAAE,EAAE;oBAAE,SAAS;oBAAE;gBAAQ;YAC9E;QACJ;IACJ;IACA,IAAI,cAAc,MAAM,KAAK,GACzB,MAAM,0NAA8B;QAAE;IAAO;IACjD,OAAO;AACX,EACA,8CAA8C"}},
    {"offset": {"line": 2531, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2536, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/parseAbiParameter.js"],"sourcesContent":["import { InvalidAbiParameterError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameter into {@link AbiParameter}\n *\n * @param param - Human-readable ABI parameter\n * @returns Parsed {@link AbiParameter}\n *\n * @example\n * const abiParameter = parseAbiParameter('address from')\n * //    ^? const abiParameter: { type: \"address\"; name: \"from\"; }\n *\n * @example\n * const abiParameter = parseAbiParameter([\n *   //  ^? const abiParameter: { type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameter(param) {\n    let abiParameter;\n    if (typeof param === 'string')\n        abiParameter = parseAbiParameter_(param, {\n            modifiers,\n        });\n    else {\n        const structs = parseStructs(param);\n        const length = param.length;\n        for (let i = 0; i < length; i++) {\n            const signature = param[i];\n            if (isStructSignature(signature))\n                continue;\n            abiParameter = parseAbiParameter_(signature, { modifiers, structs });\n            break;\n        }\n    }\n    if (!abiParameter)\n        throw new InvalidAbiParameterError({ param });\n    return abiParameter;\n}\n//# sourceMappingURL=parseAbiParameter.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAqBO,SAAS,kBAAkB,KAAK;IACnC,IAAI;IACJ,IAAI,OAAO,UAAU,UACjB,eAAe,wMAAmB,OAAO;QACrC,SAAS;IACb;SACC;QACD,MAAM,UAAU,qMAAa;QAC7B,MAAM,SAAS,MAAM,MAAM;QAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,MAAM,YAAY,KAAK,CAAC,EAAE;YAC1B,IAAI,6MAAkB,YAClB;YACJ,eAAe,wMAAmB,WAAW;gBAAE,SAAS;gBAAE;YAAQ;YAClE;QACJ;IACJ;IACA,IAAI,CAAC,cACD,MAAM,yNAA6B;QAAE;IAAM;IAC/C,OAAO;AACX,EACA,6CAA6C"}},
    {"offset": {"line": 2571, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2576, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js"],"sourcesContent":["import { InvalidAbiItemError } from './errors/abiItem.js';\nimport { isStructSignature } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseSignature } from './runtime/utils.js';\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem(signature) {\n    let abiItem;\n    if (typeof signature === 'string')\n        abiItem = parseSignature(signature);\n    else {\n        const structs = parseStructs(signature);\n        const length = signature.length;\n        for (let i = 0; i < length; i++) {\n            const signature_ = signature[i];\n            if (isStructSignature(signature_))\n                continue;\n            abiItem = parseSignature(signature_, structs);\n            break;\n        }\n    }\n    if (!abiItem)\n        throw new InvalidAbiItemError({ signature });\n    return abiItem;\n}\n//# sourceMappingURL=parseAbiItem.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAqBO,SAAS,aAAa,SAAS;IAClC,IAAI;IACJ,IAAI,OAAO,cAAc,UACrB,UAAU,qMAAe;SACxB;QACD,MAAM,UAAU,qMAAa;QAC7B,MAAM,SAAS,UAAU,MAAM;QAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,MAAM,aAAa,SAAS,CAAC,EAAE;YAC/B,IAAI,6MAAkB,aAClB;YACJ,UAAU,qMAAe,YAAY;YACrC;QACJ;IACJ;IACA,IAAI,CAAC,SACD,MAAM,+MAAwB;QAAE;IAAU;IAC9C,OAAO;AACX,EACA,wCAAwC"}},
    {"offset": {"line": 2606, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2611, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/narrow.js"],"sourcesContent":["/**\n * Infers embedded primitive type of any type\n * Same as `as const` but without setting the object as readonly and without needing the user to use it.\n *\n * @param value - Value to infer\n * @returns Value with embedded type inferred\n *\n * @example\n * const result = narrow(['foo', 'bar', 1])\n */\nexport function narrow(value) {\n    return value;\n}\n//# sourceMappingURL=narrow.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;AACM,SAAS,OAAO,KAAK;IACxB,OAAO;AACX,EACA,kCAAkC"}},
    {"offset": {"line": 2626, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2631, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/abitype/dist/esm/human-readable/formatAbi.js"],"sourcesContent":["import { formatAbiItem } from './formatAbiItem.js';\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param abi - ABI\n * @returns Human-readable ABI\n */\nexport function formatAbi(abi) {\n    const signatures = [];\n    const length = abi.length;\n    for (let i = 0; i < length; i++) {\n        const abiItem = abi[i];\n        const signature = formatAbiItem(abiItem);\n        signatures.push(signature);\n    }\n    return signatures;\n}\n//# sourceMappingURL=formatAbi.js.map"],"names":[],"mappings":";;;;;;AAOO,SAAS,UAAU,GAAG;IACzB,MAAM,aAAa,EAAE;IACrB,MAAM,SAAS,IAAI,MAAM;IACzB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,MAAM,UAAU,GAAG,CAAC,EAAE;QACtB,MAAM,YAAY,iMAAc;QAChC,WAAW,IAAI,CAAC;IACpB;IACA,OAAO;AACX,EACA,qCAAqC"}},
    {"offset": {"line": 2647, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2744, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/exports/index.js"],"sourcesContent":["// biome-ignore lint/performance/noBarrelFile: <explanation>\nexport { BaseError } from '../errors.js';\nexport { narrow } from '../narrow.js';\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Human-Readable\nexport { formatAbi, } from '../human-readable/formatAbi.js';\nexport { formatAbiItem, } from '../human-readable/formatAbiItem.js';\nexport { formatAbiParameter, } from '../human-readable/formatAbiParameter.js';\nexport { formatAbiParameters, } from '../human-readable/formatAbiParameters.js';\nexport { parseAbi } from '../human-readable/parseAbi.js';\nexport { parseAbiItem, } from '../human-readable/parseAbiItem.js';\nexport { parseAbiParameter, } from '../human-readable/parseAbiParameter.js';\nexport { parseAbiParameters, } from '../human-readable/parseAbiParameters.js';\nexport { UnknownTypeError, InvalidAbiItemError, UnknownSolidityTypeError, } from '../human-readable/errors/abiItem.js';\nexport { InvalidAbiTypeParameterError, InvalidFunctionModifierError, InvalidModifierError, SolidityProtectedKeywordError, InvalidParameterError, InvalidAbiParametersError, InvalidAbiParameterError, } from '../human-readable/errors/abiParameter.js';\nexport { InvalidStructSignatureError, InvalidSignatureError, UnknownSignatureError, } from '../human-readable/errors/signature.js';\nexport { InvalidParenthesisError } from '../human-readable/errors/splitParameters.js';\nexport { CircularReferenceError } from '../human-readable/errors/struct.js';\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"AAAA,4DAA4D;;;;;;;;;;;;;;;;;CAkB5D,iCAAiC"}},
    {"offset": {"line": 2762, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2767, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js"],"sourcesContent":["import { InvalidAbiParametersError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { splitParameters } from './runtime/utils.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters(params) {\n    const abiParameters = [];\n    if (typeof params === 'string') {\n        const parameters = splitParameters(params);\n        const length = parameters.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter_(parameters[i], { modifiers }));\n        }\n    }\n    else {\n        const structs = parseStructs(params);\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            const signature = params[i];\n            if (isStructSignature(signature))\n                continue;\n            const parameters = splitParameters(signature);\n            const length = parameters.length;\n            for (let k = 0; k < length; k++) {\n                abiParameters.push(parseAbiParameter_(parameters[k], { modifiers, structs }));\n            }\n        }\n    }\n    if (abiParameters.length === 0)\n        throw new InvalidAbiParametersError({ params });\n    return abiParameters;\n}\n//# sourceMappingURL=parseAbiParameters.js.map"],"names":[],"mappings":";;;;;;;;;;;;;AAsBO,SAAS,mBAAmB,MAAM;IACrC,MAAM,gBAAgB,EAAE;IACxB,IAAI,OAAO,WAAW,UAAU;QAC5B,MAAM,aAAa,8NAAgB;QACnC,MAAM,SAAS,WAAW,MAAM;QAChC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,cAAc,IAAI,CAAC,gOAAmB,UAAU,CAAC,EAAE,EAAE;gBAAE,SAAS;YAAC;QACrE;IACJ,OACK;QACD,MAAM,UAAU,6NAAa;QAC7B,MAAM,SAAS,OAAO,MAAM;QAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,MAAM,YAAY,MAAM,CAAC,EAAE;YAC3B,IAAI,qOAAkB,YAClB;YACJ,MAAM,aAAa,8NAAgB;YACnC,MAAM,SAAS,WAAW,MAAM;YAChC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;gBAC7B,cAAc,IAAI,CAAC,gOAAmB,UAAU,CAAC,EAAE,EAAE;oBAAE,SAAS;oBAAE;gBAAQ;YAC9E;QACJ;IACJ;IACA,IAAI,cAAc,MAAM,KAAK,GACzB,MAAM,kPAA8B;QAAE;IAAO;IACjD,OAAO;AACX,EACA,8CAA8C"}},
    {"offset": {"line": 2811, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2816, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameter.js"],"sourcesContent":["import { InvalidAbiParameterError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameter into {@link AbiParameter}\n *\n * @param param - Human-readable ABI parameter\n * @returns Parsed {@link AbiParameter}\n *\n * @example\n * const abiParameter = parseAbiParameter('address from')\n * //    ^? const abiParameter: { type: \"address\"; name: \"from\"; }\n *\n * @example\n * const abiParameter = parseAbiParameter([\n *   //  ^? const abiParameter: { type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameter(param) {\n    let abiParameter;\n    if (typeof param === 'string')\n        abiParameter = parseAbiParameter_(param, {\n            modifiers,\n        });\n    else {\n        const structs = parseStructs(param);\n        const length = param.length;\n        for (let i = 0; i < length; i++) {\n            const signature = param[i];\n            if (isStructSignature(signature))\n                continue;\n            abiParameter = parseAbiParameter_(signature, { modifiers, structs });\n            break;\n        }\n    }\n    if (!abiParameter)\n        throw new InvalidAbiParameterError({ param });\n    return abiParameter;\n}\n//# sourceMappingURL=parseAbiParameter.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAqBO,SAAS,kBAAkB,KAAK;IACnC,IAAI;IACJ,IAAI,OAAO,UAAU,UACjB,eAAe,gOAAmB,OAAO;QACrC,SAAS;IACb;SACC;QACD,MAAM,UAAU,6NAAa;QAC7B,MAAM,SAAS,MAAM,MAAM;QAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,MAAM,YAAY,KAAK,CAAC,EAAE;YAC1B,IAAI,qOAAkB,YAClB;YACJ,eAAe,gOAAmB,WAAW;gBAAE,SAAS;gBAAE;YAAQ;YAClE;QACJ;IACJ;IACA,IAAI,CAAC,cACD,MAAM,iPAA6B;QAAE;IAAM;IAC/C,OAAO;AACX,EACA,6CAA6C"}},
    {"offset": {"line": 2851, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2856, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js"],"sourcesContent":["import { InvalidAbiItemError } from './errors/abiItem.js';\nimport { isStructSignature } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseSignature } from './runtime/utils.js';\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem(signature) {\n    let abiItem;\n    if (typeof signature === 'string')\n        abiItem = parseSignature(signature);\n    else {\n        const structs = parseStructs(signature);\n        const length = signature.length;\n        for (let i = 0; i < length; i++) {\n            const signature_ = signature[i];\n            if (isStructSignature(signature_))\n                continue;\n            abiItem = parseSignature(signature_, structs);\n            break;\n        }\n    }\n    if (!abiItem)\n        throw new InvalidAbiItemError({ signature });\n    return abiItem;\n}\n//# sourceMappingURL=parseAbiItem.js.map"],"names":[],"mappings":";;;;;;;;;;;;AAqBO,SAAS,aAAa,SAAS;IAClC,IAAI;IACJ,IAAI,OAAO,cAAc,UACrB,UAAU,6NAAe;SACxB;QACD,MAAM,UAAU,6NAAa;QAC7B,MAAM,SAAS,UAAU,MAAM;QAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,MAAM,aAAa,SAAS,CAAC,EAAE;YAC/B,IAAI,qOAAkB,aAClB;YACJ,UAAU,6NAAe,YAAY;YACrC;QACJ;IACJ;IACA,IAAI,CAAC,SACD,MAAM,uOAAwB;QAAE;IAAU;IAC9C,OAAO;AACX,EACA,wCAAwC"}},
    {"offset": {"line": 2886, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2891, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/narrow.js"],"sourcesContent":["/**\n * Infers embedded primitive type of any type\n * Same as `as const` but without setting the object as readonly and without needing the user to use it.\n *\n * @param value - Value to infer\n * @returns Value with embedded type inferred\n *\n * @example\n * const result = narrow(['foo', 'bar', 1])\n */\nexport function narrow(value) {\n    return value;\n}\n//# sourceMappingURL=narrow.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;AACM,SAAS,OAAO,KAAK;IACxB,OAAO;AACX,EACA,kCAAkC"}},
    {"offset": {"line": 2906, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2911, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbi.js"],"sourcesContent":["import { formatAbiItem } from './formatAbiItem.js';\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param abi - ABI\n * @returns Human-readable ABI\n */\nexport function formatAbi(abi) {\n    const signatures = [];\n    const length = abi.length;\n    for (let i = 0; i < length; i++) {\n        const abiItem = abi[i];\n        const signature = formatAbiItem(abiItem);\n        signatures.push(signature);\n    }\n    return signatures;\n}\n//# sourceMappingURL=formatAbi.js.map"],"names":[],"mappings":";;;;;;AAOO,SAAS,UAAU,GAAG;IACzB,MAAM,aAAa,EAAE;IACrB,MAAM,SAAS,IAAI,MAAM;IACzB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,MAAM,UAAU,GAAG,CAAC,EAAE;QACtB,MAAM,YAAY,yNAAc;QAChC,WAAW,IAAI,CAAC;IACpB;IACA,OAAO;AACX,EACA,qCAAqC"}},
    {"offset": {"line": 2927, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}